': This program was generated by
': InForm - GUI system for QB64 - Beta version 3
': Fellippe Heitor, 2016 - fellippe@qb64.org - @fellippeheitor
'-----------------------------------------------------------

': Controls' IDs: ------------------------------------------------------------------
DIM SHARED MazeBuilder AS LONG
DIM SHARED Ccursor AS LONG
DIM SHARED Frame3 AS LONG
DIM SHARED Frame2 AS LONG
DIM SHARED Frame1 AS LONG 'over-frame of 2 and 3
DIM SHARED Brush1 AS LONG
DIM SHARED Brush2 AS LONG
DIM SHARED Brush3 AS LONG
DIM SHARED Brush4 AS LONG
DIM SHARED Brush5 AS LONG
DIM SHARED Brush6 AS LONG
DIM SHARED Brush7 AS LONG
DIM SHARED Brush8 AS LONG
DIM SHARED Brush9 AS LONG
DIM SHARED Brush10 AS LONG
DIM SHARED Brush11 AS LONG
DIM SHARED Brush12 AS LONG
DIM SHARED Area AS LONG
DIM SHARED StandardBT AS LONG
DIM SHARED SlowingBT AS LONG
DIM SHARED LabelTT AS LONG
DIM SHARED TTText AS LONG

DIM SHARED HardBT AS LONG
DIM SHARED KeyedBT AS LONG
DIM SHARED OneWayBT AS LONG
DIM SHARED ZoomBar AS LONG
DIM SHARED expandLB AS LONG
DIM SHARED EnterBT AS LONG
DIM SHARED LoadBT AS LONG
DIM SHARED SaveBT AS LONG

DIM SHARED Scrolltrial AS LONG
DIM SHARED Scrolltrial2 AS LONG
DIM SHARED ExpandBT AS LONG
DIM SHARED TopRB AS LONG '
DIM SHARED BottomRB AS LONG
DIM SHARED RightRB AS LONG
DIM SHARED LeftRB AS LONG
DIM SHARED ExpandBar AS LONG
DIM SHARED ApplyBT AS LONG

DIM SHARED __drag_complete AS _BYTE
DIM SHARED BrushLevelList AS LONG
DIM SHARED Cursor AS LONG

CONST __uix_unfiltered = -2
CONST Right = 2, Left = 1, Middle = 3


REDIM SHARED uix_sweeplist(0) AS LONG

' MazeBuilder Base Types
'  * * * * * please copy this into your target application
TYPE intpair
    a AS INTEGER
    z AS INTEGER
END TYPE
TYPE singpair
    sa AS SINGLE
    sz AS SINGLE
END TYPE
CONST None = 0, Chamb = 1, Cave = 2, MajorTreasure = 7, miNorTreasure = 8, Market = 5
CONST Fount = 3, Relic = 6, Shrine = 4, Entry = 9
CONST Tunnel = 20, Slide = 30, Slowing = 40, Guarded = 50

'bla!
REDIM SHARED My.sweeplist(0) AS LONG


TYPE room
' firsttypeelement AS _UNSIGNED _BYTE
    now AS INTEGER ' as unique index
    rmdesc AS _BYTE
    isof AS INTEGER
    rmelab AS STRING * 8
    ' ^ possible ideas:
    ' * feature of merged path * idx of a room descr * unique treasure * class name
    exit1 AS INTEGER
    exit2 AS INTEGER
    exit3 AS INTEGER
    exit4 AS INTEGER
    exit5 AS INTEGER
    exit6 AS INTEGER
    exit7 AS INTEGER
    exit8 AS INTEGER
END TYPE
TYPE roomsup
    offset AS intpair 'internal calc
    customoffset AS intpair
    'clock face positioning of the tunnel graphics
    exit1 AS _BYTE
    exit2 AS _BYTE
    exit3 AS _BYTE
    exit4 AS _BYTE
    exit5 AS _BYTE
    exit6 AS _BYTE
    exit7 AS _BYTE
    exit8 AS _BYTE
END TYPE
TYPE MazebuildProps
    formwidth AS INTEGER
    formheight AS INTEGER
    roomwidth AS INTEGER
    roomheight AS INTEGER
    brush AS INTEGER

END TYPE
TYPE InputControl
    dragstart AS SINGLE
    dragcontext AS LONG
    dragon AS _BYTE
    dclickstart AS SINGLE
END TYPE

CONST res_room = 1, res_cave = 2, res_foun = 3, res_shri = 4
CONST dblclick_thresh = .29 'seconds that may pass between clicks
CONST drag_thresh = .35 'seconds that may pass before a mousedown is treated as a drag

DIM zoom_mults(8) AS SINGLE

DIM SHARED app AS MazebuildProps, appctl AS InputControl
DIM SHARED AreaCursor AS InputControl
DIM SHARED FoundRes(20) AS STRING, happres(20) AS LONG
DIM SHARED scroll.top, scroll.left, zoom.value ', zoom.width, zoom.height

redim SHARED rooms(0) AS room, paths(0) AS room, _
        visualfacts(0  ) AS roomsup, roomboxsize as intpair

REDIM SHARED lib_rooms_main(0) AS room, lib_roomsup_main(0) AS room 'as opposed to roomboxsize these are buffers of parts of main box

REDIM SHARED AreaArr(0, 0) AS LONG, areadim AS intpair
DIM SHARED VirtualOffset AS intpair
DIM SHARED controlrange.max AS LONG, controlrange.min AS LONG

LoadResources

'$INCLUDE:'InForm\InForm.ui'
'$INCLUDE:'InForm\xp.uitheme'
'$INCLUDE:'MazeBuilder10B.frm'

': Event procedures: ---------------------------------------------------------------
SUB __UI_BeforeInit
__orgwidth_Area = _WIDTH: __orgheight_Area = _HEIGHT

END SUB

SUB __UI_OnLoad


'  # # # # # swaps

'SWAP Control(Frame1), Control(Frame3)
'SWAP Control(Frame1).ID, Control(Frame3).ID
's1i = Frame1: s2i = Frame3
'FOR i& = 101 TO UBOUND(control)
'    pi = Control(i&).ParentID
'    IF pi = s1i THEN Control(i&).ParentID = s2i ELSE IF pi = s2i THEN Control(i&).ParentID = s1i
'NEXT i&


app.brush = Chamb
Caption(Brush1) = "Chamb": Caption(Brush2) = "Cave"
Caption(Brush3) = "Fount": Caption(Brush4) = "Shrine"
'CONST None = 0, Chamb = 1, Cave = 2, MajorTreasure = 7, miNorTreasure = 8, Market = 5
'CONST Fount = 3, Relic = 6, Shrine = 4, Entry = 9

FOR i = 1 TO 5
    AddItem BrushLevelList, STR$(i)
NEXT



InVisiblate
'Cursor = Zupreme(Cursor)
BeginDraw Cursor
DIM this AS __UI_ControlTYPE
CLS , &H606868C0
Control(Cursor).HasBorder = False
this = Control(Cursor)

LINE (this.Width * .2, this.Height \ 2)-STEP(this.Width * .6, 0), &HFFFF3F3F
CIRCLE STEP(4, 0), 5, &HFFFF3F3F: CIRCLE STEP(-8 - this.Width * .6, 0), 5, &HFFFF3F3F
LINE (this.Width \ 2, this.Height * .2)-STEP(0, this.Height * .6), &HFFFF3F3F
CIRCLE STEP(0, 4), 5, &HFFFF3F3F: CIRCLE STEP(0, -8 - this.Height * .6), 5, &HFFFF3F3F
EndDraw Cursor

' Work cosmetic adjustments
'  Control(Frame1).Left = Control(ExpandBT).Left-30-     Control(Frame1).Width
'  Control(Frame3).Left=Control(ExpandBT).Left-30-     Control(Frame3).Width

'Control(Ccursor).BackColor = Control(Ccursor).BackColor AND &H00FFFFFF
'no good, destroy

Control(Frame1).Hidden = True
'Control(Frame2).Hidden = True
'ok= __ui_newcontrol( __ui_type_ ,1,1,1,1,0)
'Control(Frame3).Hidden = True

'frame doesn't work for me, try picbox
DIM holder_x AS __UI_ControlTYPE
holder_x = Control(Ccursor)
__UI_DestroyControl Control(Ccursor)
Ccursor = __UI_NewControl(__UI_Type_PictureBox, "Ccursor", holder_x.Width, holder_x.Height, holder_x.Left, holder_x.Top, 0)
BeginDraw Ccursor
CLS , &H00FFFFFF

FOR i = 1 TO 7
    LINE (i, i)-(Control(Ccursor).Width - i - 1, Control(Ccursor).Height - i - 1), _RGB32(164, 76, 0), B
NEXT i
Control(Ccursor).BackColor = Control(Ccursor).BackColor AND &H00FFFFFF
EndDraw Ccursor
''Control(Area).Width = 30: Control(Area).Height = 30


'Various preemptive inits
PlaceToScale True

'Set up zoomer and scroller(s)
Control(Scrolltrial2).HasBorder = True 'False
Control(Scrolltrial2).Disabled = False
FOR i = 1 TO 48
    AddItem Scrolltrial2, "HH. H"
NEXT i
'Control(Scrolltrial).HasBorder = False
Control(Scrolltrial).Disabled = False
Control(Area).Disabled = False
'Control(Scrolltrial).Min = 1: Control(Scrolltrial).Max = 10: Control(Scrolltrial).Interval = 2

'Control(Frame2).Top = Control(expandLB).Top + Control(expandLB).Height + 15
'Control(Frame2).Left = Control(expandLB).Left - 34
'Control(Frame3).Top = Control(expandLB).Top + Control(Frame).Height + Control(expandLB).Height + 12
'Control(Frame3).Left = Control(expandLB).Left - 34
Control(Frame2).Top = Control(ExpandBT).Top + Control(Frame2).Height
Control(Frame2).Left = Control(ExpandBT).Left - 34 - Control(Frame2).Width
Control(Frame3).Top = Control(expandLB).Top + Control(Frame3).Height * 2
Control(Frame3).Left = Control(expandLB).Left - 34 - Control(Frame3).Width
Control(Frame2).HasBorder = False
Control(Frame3).HasBorder = False
Control(RightRB).Value = True
Control(BottomRB).Value = True

' SAMPLE- Set up blank area
Control(Area).Width = Control(Area).Width - 75

LoadProj 1

'?consider minimum creation requirements when calling __UI_NewControl
'?for frame, .VAlign
'for button, .Font


END SUB

SUB __UI_BeforeUpdateDisplay
'   ^ &)     ^ &      ^ &     ^ &      ^ &     ^ &      ^ &     ^ &      ^ &     ^ &)

__drag_complete = False
IF __UI_MouseButton1 THEN
    IF AreaCursor.dragstart > 0 THEN IF TIMER(.001) > AreaCursor.dragstart AND ABS(AreaCursor.dragstart - TIMER(.001)) < 50000 THEN AreaCursor.dragon = True: AreaCursor.dragstart = -1

END IF
'IF AreaCursor.dragstart > 0 AND TIMER(.001) > AreaCursor.dragstart THEN AreaCursor.dragon = True ' : AreaCursor.dragstart = 0
'override an event

SHARED onlyonce_1: onlyonce_1 = True 'or for e.g. for once only process

'''' detect hovers    ''''

DIM pp AS intpair, pq AS intpair

pp.a = __UI_MouseLeft: pp.z = __UI_MouseTop

pq.a = pp.a: pq.z = pp.z
CALL SweepControls(pp, pq)
REDIM My.sweeplist(UBOUND(uix_sweeplist)) AS LONG
FOR i = UBOUND(uix_sweeplist) TO 1 STEP -1: My.sweeplist(i) = uix_sweeplist(i): NEXT i
REDIM uix_sweeplist(0) AS LONG

' when design mode active, ie when dragging a tile:
' watch that controls don't get the design cursor, etc
IF __UI_DesignMode THEN
    FOR i = 1 TO UBOUND(control)
        IF Control(i).Type <> 0 THEN Control(i).ControlIsSelected = False
    NEXT i
: END IF
IF __UI_IsDragging THEN
    PathOrSwap
END IF
IF __UI_MouseButton1 = 0 THEN __UI_DesignMode = False



'STATIC ms_type&& ' doesn't srike the rite aesthetic
'IF Feel = Area THEN ms_type&& = ms_type&& XOR -1: IF ms_type&& THEN _MOUSEHIDE: _MOUSESHOW "TOPLEFT_BOTTOMRIGHT" ELSE _MOUSEHIDE: _MOUSESHOW "TOPRIGHT_BOTTOMLEFT" 'did not really work as expected
'IF Feel <> Area THEN _MOUSESHOW "DEFAULT"

'''''''' work the hotkeys

'disused
'UI_or_KeyPress My.sweeplist()


'got any single do flags?
SHARED fSingle_area_click_done AS _BYTE
fSingle_area_click_done = False

STATIC newRMBstate AS _BYTE, prevRMBstate AS _BYTE
prevRMBstate = newRMBstate: newRMBstate = RMBstate


IF NOT (prevRMBstate IMP newRMBstate) THEN

    FOR i = UBOUND(My.sweeplist) TO 0 STEP -1
        IF i = 0 THEN
            cin = My.sweeplist(UBOUND(My.sweeplist))
        ELSE
            IF Control(My.sweeplist(i)).Type = __UI_Type_Frame THEN cin = My.sweeplist(i): EXIT FOR
        END IF ' prioritizes frames (as tile containers)

    NEXT i
    __UI_MouseUp -cin '-Area
END IF 'onetime rmb hand-o

'if you ensure that focus stays on something which accepts keypresses, then see in keypress sub about keyhit
IF INSTR("3, 5,6,7,8,9,10,11,12,13, 15", LTRIM$(STR$(Control(__UI_Focus).Type))) = 0 THEN
    FOR i = 101 TO UBOUND(control): IF Control(i).Type = __UI_Type_ListBox OR Control(i).Type = __UI_Type_Button THEN __UI_Focus = i: EXIT FOR
NEXT: END IF


END SUB

SUB __UI_BeforeUnload

END SUB


SUB AreaClick (id AS LONG)
SELECT CASE id
    CASE controlrange.min TO controlrange.max

        ' SHARED grg: grg = grg + 1
        ''        SetCaption button1, STR$(grg)
        ' Text(TTText) = Text(TTText) + STR$(grg)
        'frame name is set when displayed , but what if

        'translate control id to the rooms(id) ; wish for an easier way of doing this
        local_a = VirtualOffset.a - 1 + roomboxsize.a * (VirtualOffset.z - 1) + id - controlrange.min
        '!! ^ check if you're not off by 1
        rooms(local_a).rmdesc = Chamb 'app.brush
        spotchange id, local_a
        __UI_ForceRedraw = True


        spotchange id, local_a
        __UI_ForceRedraw = True
END SELECT
END SUB

SUB __UI_MouseUp (id AS LONG)


IF id < 0 THEN
    'negative id's are non-left clicks sent to here
    b_is_rmb = True
    id = -id
ELSE
    IF AreaCursor.dragon THEN __drag_complete = True: AreaCursor.dragon = False
    'modify id to point at the frame of interest
    IF __UI_MouseTop <= Control(Area).Top + Control(Area).Height THEN
        IF __UI_MouseTop >= Control(Area).Top AND __UI_MouseLeft <= Control(Area).Left + Control(Area).Width AND __UI_MouseLeft >= Control(Area).Left THEN
            IF __drag_complete THEN
                GOTO SpecialMouseUp
            ELSE
                'providing this was NOT a drag we'll skip to using AreaCursor.dragcontext for our target tile
                id = AreaCursor.dragcontext
            END IF
    END IF: END IF

END IF

SELECT CASE id

    CASE controlrange.min TO controlrange.max
        IF b_is_rmb THEN Control(id).rmdesc = None ELSE Control(id).rmdesc = app.brush
        PaintYou FindKid(id), Control(id).rmdesc
        __UI_ForceRedraw = True
    CASE Area
        '  disused:
        IF bid = Right THEN
            local_a = VirtualOffset.a - 1 + roomboxsize.a * (VirtualOffset.z - 1) + cin - controlrange.min
            rooms(local_a).rmdesc = None 'app.brush
            spotchange id, local_a
            __UI_ForceRedraw = True

        END IF


        ' CASE ApplyBT
        '    Control(Frame1).Hidden = True
        '    Control(ExpandBT).Hidden = False: Control(ExpandBT).Disabled = False
        '    Control(ZoomBar).Disabled = False
        '    __UI_ForceRedraw = True

    CASE ExpandBT
        Control(Frame1).Hidden = False
        ''' Control(Frame3).Hidden = False

        '        Control(Ccursor).Hidden = False
        '        Control(Frame).Hidden = False
        Control(ExpandBT).Hidden = True: Control(ExpandBT).Disabled = True
        Control(ZoomBar).Disabled = True
        __UI_ForceRedraw = True

        'CASE expandLB

        'CASE TopRB

        'CASE BottomRB

        'CASE RightRB

        'CASE LeftRB

        'CASE EnterBT

        'CASE LoadBT

        'CASE SaveBT

        'CASE LabelTT

        'CASE ZoomBar

    CASE ELSE
        __prevent_click = False

        'SELECT CASE __UI_BelowHoveringID
        '    CASE controlrange.min TO controlrange.max
        '        diag_call_reg "fc"
        '        'frame name is set when displayed , but what if
        '        local_a = (VirtualOffset.a - 1 + roomboxsize.a * (VirtualOffset.z - 1) + __UI_BelowHoveringID - controlrange.min)
        '        lib_rooms_main(local_a).rmdesc = 1 'app.brush
        '        ' PaintYou FindKid(id), lib_rooms_main(local_a).rmdesc
        '        MapResource rooms(local_a).rmdesc, FindKid(id)
        '        'BUT, will not work, save when a contiguous range is available
        '        '   v  & &

        'END SELECT

END SELECT
AreaCursor.dragcontext = 0: AreaCursor.dragstart = -1
SpecialMouseUp:

'check that both id and AreaCursor.dragcontext are valid tiles
'

AreaCursor.dragcontext = 0: AreaCursor.dragstart = -1

END SUB

SUB __UI_MouseEnter (id AS LONG)
SELECT CASE __UI_BelowHoveringID
    'CASE controlrange.min TO controlrange.max
    '    '   Control(Cursor).Left = Control(__UI_BelowHoveringID).Left - 6
    '    '   Control(Cursor).Top = Control(__UI_BelowHoveringID).Top - 6

    '    ' DIM this AS __UI_ControlTYPE

    '    'paint the cursor element
    '    STATIC this_stat
    '    IF this_stat = 0 THEN this_stat = _NEWIMAGE(80, 60, 32)
    '    _DEST this_stat
    '    'CLS , 0
    '    LINE (this.Width * .2, this.Height \ 2)-STEP(this.Width * .6, 0), &HFFFF3F3F
    '    CIRCLE STEP(4, 0), 5, &HFFFF3F3F: CIRCLE STEP(-8 - this.Width * .6, 0), 5, &HFFFF3F3F
    '    LINE (this.Width \ 2, this.Height * .2)-STEP(0, this.Height * .6), &HFFFF3F3F
    '    CIRCLE STEP(0, 4), 5, &HFFFF3F3F: CIRCLE STEP(0, -8 - this.Height * .6), 5, &HFFFF3F3F
    '    DIM cann(80 * 60 + 9) AS LONG
    '    GET (0, 0)-(79, 59), cann()
    '    _DEST 0
    '    BeginDraw Cursor
    '    PUT (Control(__UI_BelowHoveringID).Left - Control(controlrange.min).Left, Control(__UI_BelowHoveringID).Top - Control(controlrange.min).Top), cann(), _CLIP XOR
    '    EndDraw Cursor


END SELECT
SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame2

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

END SELECT
END SUB

SUB __UI_MouseLeave (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE Button15

    CASE Button16

    CASE Button17

    CASE TextTT

    CASE ZoomBar

    CASE Frame1, Frame2, Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT, LoadBT, SaveBT

    CASE LabelTT

    CASE ZoomBar

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_FocusIn (id AS LONG)
'SELECT CASE id
'    CASE MazeBuilder

'    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
'        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

'    CASE Area

'    CASE Area

'    CASE ApplyBT

'    CASE Button13

'    CASE Button14

'    CASE TextTT

'    CASE Button15

'    CASE Button16

'    CASE Button17

'    CASE ZoomBar

'    CASE Frame1

'    CASE Frame2

'    CASE Frame3

'    CASE Ccursor

'    CASE ExpandBT

'    CASE expandLB

'    CASE TopRB

'    CASE BottomRB

'    CASE RightRB

'    CASE LeftRB

'    CASE EnterBT

'    CASE LoadBT

'    CASE SaveBT

'    CASE LabelTT

'    CASE ZoomBar

'    CASE controlrange.min TO controlrange.max

'END SELECT
END SUB

SUB __UI_FocusOut (id AS LONG)
'SELECT CASE id
'    CASE MazeBuilder

'    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
'        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

'    CASE Area

'    CASE Area

'    CASE ApplyBT

'    CASE Button13

'    CASE Button14

'    CASE TextTT

'    CASE Button15

'    CASE Button16

'    CASE Button17

'    CASE ZoomBar

'    CASE Frame1

'    CASE Frame2

'    CASE Frame3

'    CASE Ccursor

'    CASE ExpandBT

'    CASE expandLB

'    CASE TopRB

'    CASE BottomRB

'    CASE RightRB

'    CASE LeftRB

'    CASE EnterBT

'    CASE LoadBT

'    CASE SaveBT

'    CASE LabelTT

'    CASE ZoomBar

'    CASE controlrange.min TO controlrange.max
'END SELECT
END SUB

SUB __UI_MouseDown (id AS LONG)


SHARED DoMoveCursor: DoMoveCursor = True

FOR i = 1 TO UBOUND(my.sweeplist)
    IF Control(My.sweeplist(i)).Type = __UI_Type_Frame THEN cin = My.sweeplist(i)
NEXT i
AreaCursor.dragcontext = cin
AreaCursor.dragstart = NextTime(drag_thresh)
'appctl.dclickstart = NextTime(dblclick_thresh) < should be on m-up

''''    AreaCursor.dragcontext = (FindKid(__UI_BelowHoveringID))
'        AreaCursor.dragcontext = id 'sellyID
'        AreaCursor.dragcontext = Control(FindKid(__UI_BelowHoveringID)).ParentID


SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar
END SELECT


END SUB

SUB __UI_Click (id AS LONG)

SELECT CASE id

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12
        app.brush = id + 1 - Brush1
        Control(Ccursor).Left = Control(id).Left - 9
        Control(Ccursor).Top = Control(id).Top - 8
END SELECT


END SUB

SUB __UI_KeyPress (id AS LONG)

asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))

do_once:
SHARED __cross_dispatch_top
__cross_dispatch_top = True ' about to fire an event sub, make it known its an artificial call
asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))
'    asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))

'diag
KeyF1 = 15104: KeyF2 = 15360: KeyF3 = 15616: KeyF4 = 15872: KeyF5 = 16128: KeyF6 = 16384: KeyF7 = 16640: KeyF8 = 16896


SELECT CASE LCASE$(asc_rng$)

    '!! simple, change click to __UI_MouseUp
    CASE "b": app.brush = Chamb
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "c": app.brush = Cave
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "n", "o": app.brush = MajorTreasure
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "m": app.brush = miNorTreasure
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "k": app.brush = Market
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "h": app.brush = Fount
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "i": app.brush = Relic
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "l", "v": app.brush = Entry
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "y": app.brush = Shrine
        __UI_Click Control(Brush1).ID + app.brush - 1

    CASE "10": ' app.brush =
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "11", "v": ' app.brush =
        __UI_Click Control(Brush1).ID + app.brush - 1
    CASE "13": 'app.brush =
        __UI_Click Control(Brush1).ID + app.brush - 1

    CASE ELSE: __cross_dispatch_top = False
END SELECT

SELECT CASE id
    CASE MazeBuilder

    CASE Area

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12


    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

    CASE controlrange.min TO controlrange.max
END SELECT

END SUB
SUB UI_or_KeyPress (id_list() AS LONG)
iub = UBOUND(id_list)
IF iub < 1 THEN GOTO do_once 'id stays 0
FOR m = 1 TO iub: id = id_list(m)

    do_once:
    SHARED __cross_dispatch_top
    __cross_dispatch_top = True ' about to fire an event sub, make it known its an artificial call
    asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))
    '    asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))

    'diag
    KeyF1 = 15104: KeyF2 = 15360: KeyF3 = 15616: KeyF4 = 15872: KeyF5 = 16128: KeyF6 = 16384: KeyF7 = 16640: KeyF8 = 16896
    IF ABS(__UI_KeyHit) = KeyF1 THEN __UI_ForceRedraw = True

    SELECT CASE LCASE$(asc_rng$)

        '!! simple, change click to __UI_MouseUp
        CASE "b": app.brush = Chamb
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "c": app.brush = Cave
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "n", "o": app.brush = MajorTreasure
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "m": app.brush = miNorTreasure
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "k": app.brush = Market
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "h": app.brush = Fount
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "i": app.brush = Relic
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "l", "v": app.brush = Entry
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "y": app.brush = Shrine
            __UI_Click Control(Brush1).ID + app.brush - 1

        CASE "10": ' app.brush =
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "11", "v": ' app.brush =
            __UI_Click Control(Brush1).ID + app.brush - 1
        CASE "13": 'app.brush =
            __UI_Click Control(Brush1).ID + app.brush - 1

        CASE ELSE: __cross_dispatch_top = False
    END SELECT

    'undo-able follows
if  __UI_mousetop > Control(area).top AND __UI_mousetop <=  Control(Area).top + Control(area).Height and _
 __UI_mouseleft > Control(area).Left AND __UI_mouseleft <= Control(Area).Left + Control(Area).Width  then
        IF LCASE$(asc_rng$) = "r" THEN

            'doing add single row
            'need the frameid - of the
            aid = Control(SellyID).ID

            DIM pp AS intpair, pq AS intpair
            pp.a = Control(Area).Left: pp.z = __UI_MouseTop: pq.a = __UI_MouseLeft: pq.z = __UI_MouseTop
            aid = ScanControls(pp, pq, __UI_Type_Frame, 1)


            '  areadim.z is not affected
            ''  downdist = Control(aid).Height
            ''  updist = Control(controlrange.max).Top - Control(aid).Top
            FOR i = controlrange.max TO aid STEP -1
                ''            Control(i).Top = Control(i).Top + downdist
                IF i + areadim.a > controlrange.max THEN
                    '' __UI_DestroyControl Control(FindKid&(i))
                    WipeTile FindKid&(i): Control(FindKid&(i)).Name = "-A" + STRING$(i, "a")

                ELSE
                    ChangeParent FindKid&(i), i + areadim.a
                    'now reflect the change in parent name
                    Control(i + areadim.a).Name = Control(i).Name

                END IF
            NEXT i
            'FOR i = controlrange.max - areadim.a + 1 TO controlrange.max
            '    Control(i).Top = Control(i).Top - updist
            'NEXT i

            REDIM _PRESERVE rooms(UBOUND(rooms) + roomboxsize.a) AS room, visualfacts(UBOUND(visualfacts) + roomboxsize.a) AS roomsup
            REDIM _PRESERVE paths(LBOUND(paths) + roomboxsize.a TO UBOUND(paths) + roomboxsize.a) AS room
            DIM dummy1 AS roomsup, dummy AS room
            FOR i = UBOUND(visualfacts) TO UBOUND(rooms) STEP -1 ' visualfacts has different bounds, start adjusting these
                visualfacts(i) = visualfacts(i - roomboxsize.a)
            NEXT i
            FOR i = i TO i - roomboxsize.a STEP -1: visualfacts(i) = dummy1: NEXT i
            '  DIM found_z AS intpair: Trans bid, found_z  :bid=0
            'try:
            found_z.z = ot + aid \ greater(1, areadim.a)
            '''=roomboxsize.a  (ot-1)

            '   bid = VAL(RIGHT$(Control(aid).Name, LEN(Control(aid).Name) - 2)) 'for __UI_Type_Frame



            ireach = 1 + roomboxsize.a * found_z.z
            FOR i = roomboxsize.a * roomboxsize.z TO ireach - roomboxsize.a STEP -1 'iterate the moved portion of rooms() resource!
                IF i < ireach THEN
                    IF rooms(i).isof <> 0 THEN
                        IF rooms(i).isof < i THEN
                            'do nothing, move nothing

                    END IF: END IF

                    IF found_z.z > 1 THEN IF rooms(i - roomboxsize.a).isof <> 0 THEN IF rooms(i - roomboxsize.a).isof = i THEN rooms(i + roomboxsize.a) = rooms(i): rooms(i) = dummy:: visualfacts(i + roomboxsize.a) = visualfacts(i): visualfacts(i) = dummy1:: SWAP rooms(i - roomboxsize.a), rooms(i): SWAP visualfacts(i - roomboxsize.a), visualfacts(i): descended = True
                    'if descended "-A"
                ELSE
                    'generally'
                    rooms(i + roomboxsize.a) = rooms(i)
                    visualfacts(i + roomboxsize.a) = visualfacts(i)
                    '': visualfacts(i) = dummy1::SWAP rooms(i - roomboxsize.a), rooms(i): SWAP visualfacts(i - roomboxsize.a), visualfacts(i)


                END IF 'don't forget to mirror with roomsup

            NEXT i
            roomboxsize.z = roomboxsize.z + 1

            ' also grab new lib
        END IF '~
        IF LCASE$(asc_rng$) = "t" THEN
            'also grab new lib
        END IF
    END IF
NEXT m

END SUB

SUB __UI_TextChanged (id AS LONG)
SELECT CASE id
    CASE TextTT

END SELECT
END SUB

SUB __UI_ValueChanged (id AS LONG)
SHARED scrolltr_oldval, scrolltr_oldval2
SELECT CASE id
    CASE Scrolltrial
        Control(Scrolltrial).Value = _CEIL(Control(Scrolltrial).Value)
        Horz = 1

        ok = adjust_scroll(Horz, Control(Scrolltrial).Value - scrolltr_oldval)
        ' IF ok THEN scrolltr_oldval = Control(Scrolltrial).Value ELSE Control(Scrolltrial).Value = scrolltr_oldval
    CASE Scrolltrial2
        Vert = 2
        ok = adjust_scroll(Vert, Control(Scrolltrial2).Value \ 3 - scrolltr_oldval2)
        IF ok THEN scrolltr_oldval2 = Control(Scrolltrial2).Value ELSE Control(Scrolltrial2).Value = scrolltr_oldval2
    CASE ExpandBar

    CASE ZoomBar
    CASE BrushLevelList
        prot_setZoomValue Control(id).Value



END SELECT
END SUB

SUB ChangeParent (c1 AS LONG, c2 AS LONG)
Control(c1).ParentID = Control(c2).ID
Control(c1).ParentName = Control(c2).Name
diag_call_reg "-= pc!=-"
END SUB



SUB FlameDestroy (This AS LONG)
FOR i& = 1 TO UBOUND(control)
    IF Control(i&).ParentID = Control(This).ID THEN __UI_DestroyControl Control(i&)
NEXT: __UI_DestroyControl Control(This)
END SUB

FUNCTION ScanControls& (from AS intpair, too AS intpair, c_type AS LONG, _
 helperindex AS LONG) 'it would seem useful to get the id of a control given an area;


DIM i AS LONG, j AS _INTEGER64, k AS _INTEGER64, m AS _INTEGER64, n AS _INTEGER64,_
    qual AS _BYTE, qual1 AS _BYTE, qual2 AS _BYTE, qual3 AS _BYTE, qual4 AS _BYTE, qual5 AS _BYTE
unfiltered = __uix_unfiltered

ub = UBOUND(Control): helperindex = lesser(ub, helperindex)
st_pt = 1 'use? 101
FOR si = greater(st_pt, helperindex) TO UBOUND(Control) + helperindex
    IF 0 < helperindex THEN i = greater(st_pt, si MOD ub) ELSE i = si
    IF Control(i).Type = c_type THEN
        fusilli:
        '         dealing with top right and bottom left corners
        k = Control(i).Top: j = Control(i).Left + Control(i).Width ' :  k  j
        n = Control(i).Top + Control(i).Height: m = Control(i).Left '  :  n  m
        DO
            IF k >= from.z THEN
                IF k <= too.z THEN
                    IF j >= from.a THEN
                        IF j <= too.a THEN
                            qual1 = True: EXIT DO
            END IF: END IF: END IF: END IF
            IF n >= from.z THEN
                IF n <= too.z THEN
                    IF m >= from.a THEN
                        IF m <= too.a THEN
                            qual2 = True: EXIT DO
            END IF: END IF: END IF: END IF
            IF from.z >= k THEN
                IF from.z <= n THEN
                    IF from.a >= m THEN
                        IF from.a <= j THEN
                            qual3 = True: EXIT DO
                END IF: END IF: END IF
            ELSE 'from.z < k
                IF too.z > n THEN
                    IF from.a > m THEN
                        IF too.a < j THEN
                            qual5 = True: EXIT DO
                END IF: END IF: END IF

            END IF
            IF too.z <= n THEN
                IF too.z >= k THEN

                    IF too.a >= m THEN
                        IF too.a <= j THEN
                            qual4 = True: EXIT DO
                END IF: END IF: END IF
                ' too.z < n
                IF from.z > k THEN
                    IF too.a > j THEN
                        IF from.a < m THEN
                            qual5 = True: EXIT DO
            END IF: END IF: END IF: END IF
            EXIT DO
        LOOP
        IF qual1 OR qual2 OR qual3 OR qual4 OR qual5 THEN qual = True: EXIT FOR
        '            IF  Control(x).Top+ THEN
        '            ELSE '1st check

        '            END IF



        '             1  1             1  1
        '              2    2        2      2
        '             1  1             1  1
        '              2     2       2      2

        '               2    2
        '             1  1           1      1
        '               2    2
        '             1  1              2      2
        '                            1      1
        '                               2      2

    ELSEIF c_type = unfiltered THEN
        GOTO fusilli
    END IF
NEXT
IF qual THEN ScanControls& = i

END SUB


SUB SweepControls (from AS intpair, too AS intpair)
' given a (?)point or an area -
' enable detection of more than two hoverables


'can be part of the effort to create an easy way to establish tab order
'NI: optionally change names ;* remember to scan for children controls and duplicate change
STATIC def__ar AS _BYTE, collection() AS LONG
IF NOT def__ar THEN DIM collection(0) AS LONG: def__ar = -1
SHARED ctrllistst
ctrllistst = 101 'control.list.start = 101
REDIM _PRESERVE collection(UBOUND(collection) + 1) AS LONG

'?
IF fout THEN fi& = 0 ' does this prevent oor errors on uix_sweeplist ?
'?

FOR i% = ctrllistst TO UBOUND(control)
    ' 'SetCaption (Brush10), STR$(UBOUND(control))

    ' 'SetCaption (Brush11), STR$(ScanControls(from, too, __uix_unfiltered, 22))


    'scancontrols& (from , too, __uix_unfiltered)
    mout = (fout + 1) MOD UBOUND(control): IF mout = 0 THEN mout = 1 ' avoiding detecting the 0th control
    fout = ScanControls(from, too, __uix_unfiltered, mout)
    'fail' (fout -1)mod UBOUND(control) + 2 )
    '' not                      uix_sweeplist(UBOUND(uix_sweeplist)) + 1 _
    '                      )


    'big diag
    ''SELECT CASE i%
    ''    CASE 1
    ''        SetCaption Brush1, STR$(fout)
    ''    CASE 2
    ''        SetCaption Brush2, STR$(fout)
    ''    CASE 3
    ''        SetCaption Brush3, STR$(fout)
    ''    CASE 4
    ''        SetCaption Brush4, STR$(fout)
    ''END SELECT
    ''SetCaption Brush6, STR$(from.a)

    ''SetCaption Brush5, STR$(from.z)


    IF fout THEN
        fi& = fi& + 1
        IF fi& > 1 THEN ' ubouns(uix_sweeplist) > 0

            '?a sub range error found in the following line '
            IF fout <> uix_sweeplist(1) THEN REDIM _PRESERVE uix_sweeplist(i%) AS LONG: uix_sweeplist(i%) = fout ELSE EXIT FOR
        ELSE
            REDIM _PRESERVE uix_sweeplist(i%) AS LONG: uix_sweeplist(i%) = fout
        END IF
    END IF
NEXT i%


END SUB

FUNCTION Feel&: Feel& = __UI_HoveringID
END FUNCTION


FUNCTION SellyID&
sellyIDh = (Feel)
'FOR x = 1 TO 3 ' dig
'    IF Control(sellyIDh).Type = __UI_Type_Frame THEN EXIT FOR
'    sellyIDh = Control(sellyIDh).ParentID
'NEXT
'IF sellyIDh < controlrange.min OR sellyIDh > controlrange.max THEN EXIT FUNCTION
'SellyID& = sellyIDh
''BTW: if the name is set when tile is loaded in, this gives the right ##s of the maze index
''    = VAL(RIGHT$(Control(sellyID).Name, LEN(Control(sellyID).Name) - 2)) for __UI_Type_Frame
END FUNCTION


FUNCTION Failed1Zupreme& (This AS LONG)
'a typical call would look like this: Button32=Zupreme(Button32)
DIM i AS LONG, ub AS LONG, dummy AS __UI_ControlTYPE, str_dummy(1 TO 8) AS STRING

FOR i = 1 TO UBOUND(Control)
    'except this seems wrong...
    IF Control(i).ID <> 0 THEN ub = i: IF This > ub THEN Zupreme& = This: EXIT FUNCTION ELSE EXIT FOR
NEXT i
Zupreme& = ub
IF ub - This > 200 THEN n$ = ErrorCage("awkwardly large z-upreming") 'optionally so
dummy = Control(This)
str_dummy(1) = Caption(This): str_dummy(2) = ToolTip(This): str_dummy(3) = Text(This): str_dummy(4) = Mask(This): str_dummy(5) = __UI_TempTexts(This): str_dummy(6) = __UI_TempCaptions(This): str_dummy(7) = __UI_TempTips(This): str_dummy(8) = __UI_TempMask(This)
FOR i = This TO ub - 1
    Control(i) = Control(i + 1): Caption(i) = Caption(i + 1): ToolTip(i) = ToolTip(i + 1): Text(i) = Text(i + 1): Mask(i) = Mask(i + 1)
    Control(i).ID = i: __UI_TempTexts(i) = __UI_TempTexts(i + 1): __UI_TempCaptions(i) = __UI_TempCaptions(i + 1): __UI_TempTips(i) = __UI_TempTips(i + 1): __UI_TempMask(i) = __UI_TempMask(i + 1)
NEXT i
Control(ub) = dummy: Control(ub).ID = ub
Caption(ub) = str_dummy(1): ToolTip(ub) = str_dummy(2): Text(ub) = str_dummy(3): Mask(ub) = str_dummy(4): __UI_TempTexts(ub) = str_dummy(5): __UI_TempCaptions(ub) = str_dummy(6): __UI_TempTips(ub) = str_dummy(7): __UI_TempMask(ub) = str_dummy(8)

FOR i = 1 TO UBOUND(control)
    pi = Control(i).ParentID
    IF pi = This THEN Control(i).ParentID = ub
    IF pi > This THEN IF pi <= ub THEN Control(i).ParentID = pi - 1
NEXT i
' Zupreme& = 'see above
END SUB


FUNCTION FindKid& (__of&)
'returns the ID of earliest VALID child of a [frame] control
FOR i& = __of& TO UBOUND(control)
    IF Control(i&).ParentID = __of& THEN FindKid& = i&: EXIT FOR
NEXT i&
END FUNCTION

SUB LoadProj (inst AS INTEGER)
'  ()  ()  ()  ()  initialization of the view takes place here

CONST Init_ViewW = 11
CONST Init_ViewH = 9



IF inst = 2 THEN GOTO load_existing:

load_blank:

areadim.a = Init_ViewW: areadim.z = Init_ViewH

'!examp
roomboxsize.a = areadim.a: roomboxsize.z = areadim.z:

'virtual components
REDIM rooms(roomboxsize.a * roomboxsize.z) AS room
REDIM visualfacts(areadim.a * areadim.z) AS roomsup

ADvalidate

'cleanup (as needed)
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        px = AreaArr(ix, iy)
        IF px THEN
            noti = FindKid(px): IF noti > 0 THEN __UI_DestroyControl Control(noti)
            __UI_DestroyControl Control(px) ' mean for the control to have contiguous indices
        END IF
NEXT: NEXT
ERASE AreaArr: REDIM AreaArr(areadim.a, areadim.z) AS LONG

'diag
rooms(1).rmdesc = Chamb: rooms(2 + areadim.z).rmdesc = Chamb

'AreaArr(ix, iy)
' offset a buncha new widgets from the picturebox's vertex
box = Control(Area).Left: boy = Control(Area).Top
SHARED prefix1$2, prefix2$2: prefix1$2 = "^A": prefix2$2 = "AA"
FOR ix = 1 TO areadim.a ' UBOUND(areaarr, 1)
    FOR iy = 1 TO areadim.z ' UBOUND(areaarr, 2)
        ic& = ic& + 1
        '  AreaArr(ix, iy) = __UI_NewControl(__UI_Type_PictureBox, "AA" + LTRIM$(STR$(ic&)), zoom.width, zoom.height, (ix - 1) * zoom.width, (iy - 1) * zoom.height, Area)
        '  AreaArr(ix, iy) = __UI_NewControl(__UI_Type_Frame, "^A" + LTRIM$(STR$(ic&)), zoom.width, zoom.height, box + (ix - 1) * zoom.width, boy + (iy - 1) * zoom.height, 0)
        'at unscaled size here
        SHARED zoom.crit

        ' diag
        IF (ix - 1) * app.roomwidth * zoom.width = 0 THEN app.roomwidth = 80: zoom.crit = True: app.roomheight = 53:


        AreaArr(ix, iy) = __UI_NewControl(__UI_Type_Frame, prefix1$2 + LTRIM$(STR$(ic&))_
            , app.roomwidth* zoom.width - 1, app.roomheight* zoom.height-1,_
            box + (ix - 1) * app.roomwidth * zoom.width, boy + (iy - 1) * app.roomheight * zoom.height, 0)
        Control(AreaArr(ix, iy)).HasBorder = False
        Control(AreaArr(ix, iy)).BackColor = Control(AreaArr(ix, iy)).BackColor AND &H00FFFFFF
        'u' set em clear
NEXT: NEXT: ic& = 0
controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)
'now same
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        ic& = ic& + 1
        'u'  nameless = __UI_NewControl(__UI_Type_PictureBox, "AA" + LTRIM$(STR$(ic&)), zoom.width, zoom.height, 1, 1, AreaArr(ix, iy))
        '?"        nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 1, 1, AreaArr(ix, iy))
        'is !THIS why?         nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 1, 1, AreaArr(ix, iy))
        nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 0, 0, AreaArr(ix, iy))


        IF Control(AreaArr(ix, iy)).Value < 1 THEN Control(AreaArr(ix, iy)).Value = 1

        'u' Control(AreaArr(ix, iy)).Hidden = True
        IF ix MOD 2 THEN 'ix <= 2 AND iy <= 3 THEN
            ''''  MapResource 0, AreaArr(ix, iy)
            ''LoadImage Control(nameless), "res_mb/blnk.room.jpg"

            '  assumes a 1,1 view offset rooms((-1 + iy) * roomboxsize.a + ix
            'or
            '  local_a =  roomboxsize.a * (VirtualOffset.z - 1) + VirtualOffset.a - 1 + id - controlrange.min


            spotchange FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc

            PaintYou FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc
        ELSE
            'don't it work?
            ' MapResource 0, nameless
            '  MapResource 0, FindKid(AreaArr(ix, iy))
            PaintYou FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc

        END IF

        ''LoadImage Control(nameless), "res_mb/blnk.room.jpg" '/reshandles(res_room )
NEXT: NEXT



VirtualOffset.a = 1: VirtualOffset.z = 1

'Cursor = Zupreme(Cursor)



GOTO sub_end
'-
load_existing:

sub_end:

END SUB

SUB prim_expand
roomboxsize.a = roomboxsize.a + areadim.a
roomboxsize.z = roomboxsize.z

'virtual components
REDIM _PRESERVE rooms(roomboxsize.a * roomboxsize.z) AS room
REDIM _PRESERVE visualfacts(areadim.a * areadim.z) AS roomsup

END SUB

SUB ReadFile (spec$)
spec$ = "default"

IF _FILEEXISTS(spec$ + ".bil") THEN
ELSE
    PRINT "file name "; spec$; " not found in current path"
    EXIT SUB
END IF

REDIM dummy(0) AS room, dummys(0) AS roomsup: struc.size = LEN(dummy(0)): sup.size = LEN(dummys(0)): ERASE dummy, dummys

h1 = FREEFILE
OPEN spec$ + ".bil" FOR INPUT AS h1

mapdat$ = INPUT$(4, h1)


'discover sizes
IF LOF(h1) >= ver_h_size + 4 THEN mapdat$ = INPUT$(ver_h_size, h1)
mapver$ = RIGHT$(mapdat$, 8)
IF MID$(mapver$, 3, 1) = "." AND MID$(mapver$, 6, 1) = "." THEN
ELSE
    PRINT "format not recognized for file name "; spec$
    EXIT SUB
END IF

SHARED __incr_pos AS LONG
__incr_pos = ver_h_size 'len of what was already read


header_size = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :header_size=cvl(mapdat$)
Readsiz_rm = Readalong(h1) ' mapdat$ = INPUT$(4, h1) :Readsiz_rm=cvl(mapdat$)
Readsiz_pt = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_pt=cvl(mapdat$)
Readsiz_ot = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_ot=cvl(mapdat$)
Readsiz_cv = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_cv=cvl(mapdat$)
nul$ = Readabunch(header_size - __incr_pos, h1)

loopquan = Readsiz_rm \ struc.size 'ln - header.size
REDIM _PRESERVE rooms(0 TO loopquan) AS room
FOR i = 0 TO loopquan
    mapdat$ = Readabunch(struc.size, h1)
    IF i > 0 THEN
        RT__room rooms(i), mapdat$
    ELSE
        DIM holder AS room
        RT__room holder, mapdat$
        '! set the rooms x and y vars = .now and .isof
    END IF
NEXT i

''   REDIM _PRESERVE paths( loopquan to  loopquan ) AS room
loopquan = Readsiz_pt \ struc.size
''   REDIM _PRESERVE paths(lbound(paths) to lbound(paths)+  loopquan ) AS room
REDIM _PRESERVE paths(0 TO loopquan) AS room
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(struc.size, h1)
    RT__room paths(i), mapdat$
NEXT i

loopquan = Readsiz_ot \ sup.size

REDIM _PRESERVE visualchar(0 TO loopquan) AS roomsup
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(sup.size, h1)
    RT__room paths(i), mapdat$
NEXT i

'custom values section

mapdat$ = Readabunch(Readsiz_cv, h1)

'!process the c.d.


END SUB



SUB calcPathGrid (x, y)

''using screen height as size limiter - this used three places
'basex = 8: basey = 8
'boxsize = (80 - basey) \ y
'FOR a = 1 TO x
'    FOR b = 1 TO y
'        ressup(a + (b - 1) * x).offset.a = (basex + boxsize * (a - 1))
'        ressup(a + (b - 1) * x).offset.z = (basey + boxsize * (b - 1))
'NEXT b, a
END SUB

SUB addpath (ends AS intpair, pathid)
SHARED brush
'havent switched rooms() access to lib_rooms_main() access
pathid = UBOUND(path) + 1
IF pathid = 1 THEN pathid = UBOUND(res) + 1: REDIM path(pathid - 1 TO pathid) AS room
REDIM _PRESERVE path(pathid) AS room

'make sure there's a free slot in dest
FOR i = 1 TO 1
    IF rooms(ends.z).exit1 = 0 THEN

    ELSEIF rooms(ends.z).exit2 = 0 THEN

    ELSEIF rooms(ends.z).exit3 = 0 THEN

    ELSEIF rooms(ends.z).exit4 = 0 THEN

    ELSEIF rooms(ends.z).exit5 = 0 THEN

    ELSEIF rooms(ends.z).exit6 = 0 THEN

    ELSEIF rooms(ends.z).exit7 = 0 THEN

    ELSEIF rooms(ends.z).exit8 = 0 THEN

    END IF
    EXIT SUB
NEXT
'set for org
FOR i = 1 TO 1
    IF rooms(ends.a).exit1 = 0 THEN
        rooms(ends.a).exit1 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit2 = 0 THEN
        rooms(ends.a).exit2 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit3 = 0 THEN
        rooms(ends.a).exit3 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit4 = 0 THEN
        rooms(ends.a).exit4 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit5 = 0 THEN
        rooms(ends.a).exit5 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit6 = 0 THEN
        rooms(ends.a).exit6 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit7 = 0 THEN
        rooms(ends.a).exit7 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit8 = 0 THEN
        rooms(ends.a).exit8 = pathid: EXIT FOR
    END IF
    EXIT SUB
NEXT
'set for dest
FOR i = 1 TO 1
    IF rooms(ends.z).exit1 = 0 THEN
        rooms(ends.z).exit1 = pathid
    ELSEIF rooms(ends.z).exit2 = 0 THEN
        rooms(ends.z).exit2 = pathid
    ELSEIF rooms(ends.z).exit3 = 0 THEN
        rooms(ends.z).exit3 = pathid
    ELSEIF rooms(ends.z).exit4 = 0 THEN
        rooms(ends.z).exit4 = pathid
    ELSEIF rooms(ends.z).exit5 = 0 THEN
        rooms(ends.z).exit5 = pathid
    ELSEIF rooms(ends.z).exit6 = 0 THEN
        rooms(ends.z).exit6 = pathid
    ELSEIF rooms(ends.z).exit7 = 0 THEN
        rooms(ends.z).exit7 = pathid
    ELSEIF rooms(ends.z).exit8 = 0 THEN
        rooms(ends.z).exit8 = pathid
    END IF
    EXIT SUB
NEXT
'build path resource
path(pathid).exit1 = ends.a
path(pathid).exit2 = ends.z
path(pathid).rmdesc = brush
END SUB



FUNCTION Resolve (idx)
IF rooms(idx).isof = 0 THEN Resolve = idx ELSE Resolve = rooms(idx).isof
END FUNCTION


SUB LoadResources

path$ = "res_mb\"
'CONST None = 0, Chamb = 1       , Cave = 2,         Fount = 3,     Shrine = 4,         Market = 5,Relic = 6 MajorTreasure = 7, miNorTreasure = 8, Entry = 9
DATA "blnk.room.jpg","std.room.jpg","room.cave.jpg","room.fount.jpg","room.shrine.jpg","","","room.bigt.jpg","room.lilt.jpg","room.entr.jpg","ENDRES"
'CONST Tunnel = 20, Slide = 30, Slowing = 40, Guarded = 50

DO: i& = i& + 1
    READ FoundRes$(i&): FoundRes$(i&) = path$ + FoundRes$(i&)
    IF _FILEEXISTS(FoundRes$(i&)) THEN
        IF happres(i& - 1) >= -1 THEN happres(i& - 1) = _LOADIMAGE(FoundRes$(i&), 32) ELSE load_fail = i
    ELSE
        load_fail = i
    END IF
LOOP UNTIL INSTR(FoundRes$(i), "ENDRES") OR i& = 5

IF load_fail THEN n$ = ErrorCage("last load_fail at " + STR$(load_fail))

END SUB

SUB PlaceToScale (bstatic AS _BYTE)
'destroying + remaking original controls may cause a problem w this procedure
SHARED __orgwidth_Area, __orgheight_Area: IF __orgwidth_Area = 0 THEN __orgwidth_Area = Control(Area).Width
IF __orgheight_Area = 0 THEN __orgheight_Area = Control(Area).Height
'all left properties
STATIC expand_LB, Expand_BT,  __Frame2,__Frame3, _
__Expand_Bar
IF bstatic = True THEN
    recali:
    expand_LB = Control(MazeBuilder).Left - Control(expandLB).Left
    Expand_BT = Control(MazeBuilder).Left - Control(ExpandBT).Left

    '    __Frame1 = Control(MazeBuilder).Left - Control(Frame1).Left
    __Frame2 = Control(MazeBuilder).Left - Control(Frame2).Left
    __Frame3 = Control(MazeBuilder).Left - Control(Frame3).Left
    __Expand_Bar = Control(MazeBuilder).Left - Control(ExpandBar).Left


ELSE

    Control(Area).Width = __orgwidth_Area + (_RESIZEWIDTH - app.formwidth)
    ''  app.formwidth = _WIDTH(0)
    Control(Area).Height = __orgheight_Area + (_RESIZEHEIGHT - app.formheight)
    cml = Control(MazeBuilder).Left
    Control(expandLB).Left = cml - expand_LB
    Control(ExpandBT).Left = cml - Expand_BT
    Control(Frame2).Left = cml - __Frame2
    Control(Frame3).Left = cml - __Frame3
    Control(ExpandBar).Left = cml - __Expand_Bar
    '.
    '.
    '.
    __UI_ForceRedraw = True
    GOTO recali
END IF
END SUB

SUB adjustzoom (factor)

'set up the scale variables
levels_defined = 8

SHARED zoom_mults() AS SINGLE
zoom_mults(1) = 2.5
zoom_mults(2) = 1
zoom_mults(3) = 1 / 2
zoom_mults(4) = 1.3 / 3
zoom_mults(5) = 1 / 3
zoom_mults(6) = 1.4 / 4
zoom_mults(7) = 1 / 4
zoom_mults(8) = 1.5 / 5
' zoom.width= zoom_mults(zoom.level)
'zoom.height= zoom_mults(zoom.level)
''zoom.width = app.roomwidth * zoom.level: zoom.height = app.roomheight * zoom.level
'zoom.width = zoom_mults(zoom.level): zoom.height = zoom_mults(zoom.level)

' zoom.level
END SUB

FUNCTION adjust_scroll%% (d, size AS LONG)

'! FOUR _newcontrol's to adjust (add zoom scaling to size; position)

diag_call_reg_2 "ad[" '"adjs["

'scroll is defined to be a directed value between 1-10 divided into
' the ratio at the current zoom level of the total size of areadim.a,z (mixed with zoom.width;height) to the
' total h or w of the frame, Area,

'
' thus given a total size of areadim.a * zoom.width = 110 and 100 for Area width
'  scrollmag = (110 - 100) / (10 - 1)

'  scroll.top, scroll.left

scrmin = 1
scrmax = 10
scrolloutmult_thresh = .5

IF d = 1 THEN scrollmag = (areadim.a * 80 * 1 - Control(Area).Width) / (scrmax - scrmin)
IF d = 2 THEN scrollmag = (areadim.z * 53 * 1 - Control(Area).Height) / (scrmax - scrmin)
'IF d = 1 THEN scrollmag = (areadim.a ** zoom.width - Control(Area).Width) / (scrmax - scrmin)
'IF d = 2 THEN scrollmag = (areadim.z ** zoom.height - Control(Area).Height) / (scrmax - scrmin)

SetCaption Brush5, LEFT$(STR$(scrollmag), 6)

SetCaption Brush6, "m" + LEFT$(STR$(scrollmag), 6)

'   SetCaption Brush6, STR$(from.a)


IF scrollmag <= 1 THEN EXIT SUB '...no scrolling when all existing tiles can be fit

DIM scrvec AS intpair
IF d = 1 AND scroll.left + size >= scrmin AND scroll.left + size <= scrmax THEN
    scrvec.a = size * scrollmag
ELSEIF d = 2 AND scroll.top + size >= scrmin AND scroll.top + size <= scrmax THEN
    scrvec.z = size * scrollmag
END IF


IF greater(scrvec.a, scrvec.z) <> 0 THEN ' if we are go to scroll
    'method std
    'horz mv
    si = SGN(scrvec.a) / 2: si2 = SGN(scrvec.z) / 2
    diag_call_reg_2 "adjs."
    IF si THEN
        'see if zoom amt exceeds one tile
        crunchct = (scrvec.a - (zoom.width + Control(controlrange.min).Left)) \ greater(1, zoom.width) '-->ELSE crunchct = scrvec.z ... \ greater(1, zoom.height)
        'results in
        '    FOR ix = 1 * (.5 - si) + (UBOUND(areaarr, 1) - crunchct + 1) * (si + .5) TO crunchct * (.5 - si) + UBOUND(areaarr, 1) * (si + .5)
        '        '        FOR iy = 1 * ABS(si2 - .5) + (UBOUND(areaarr, 2) - crunchct + 1) * ABS(si2 + .5) TO crunchct * ABS(si2 - .5) + UBOUND(areaarr, 2) * ABS(si2 + .5)
        'will not work ^, absent si quantities negate, not zero out
        ' up -.5
        'having destroyed a row(s) or a column(s),  id the first killed frame widget
        crunched = 0
        REDIM ren_id(0) AS intpair
        FOR ix = 1 TO UBOUND(areaarr, 1)
            FOR iy = 1 TO UBOUND(areaarr, 2)
                IF ix <= crunchct * ABS(si - .5) THEN
                    GOTO linguine
                ELSEIF (si + .5) * ix > UBOUND(areaarr, 1) - crunchct THEN
                    linguine: 'label
                    FlameDestroy AreaArr(ix, iy)
                    IF crunched = 0 THEN crunched = ix
                    ps = UBOUND(ren_id) + 1
                    REDIM _PRESERVE ren_id(ps) AS intpair
                    ren_id(ps).a = ix: ren_id(ps).z = iy
                ELSE
                   Control(AreaArr(ix, iy)).Left=_
                      Control(AreaArr(ix, iy)).Left + scrvec.a
                END IF

        NEXT: NEXT
        '   then produce the number of widgets that got destroyed...
        IF crunched THEN
            ren_start = 0
            box = Control(Area).Left: boy = Control(Area).Top
            ''FOR ix = 1 TO (si + .5) * crunchct + UBOUND(areaarr, 1) * ABS(si - .5)
            i2 = (.5 - si) * (UBOUND(areaarr, 1) - crunchct)
            FOR ix = 1 TO crunchct
                FOR iy = 1 TO UBOUND(areaarr, 2)
                    AreaArr(ix + i2, iy) = __UI_NewControl(__UI_Type_Frame, prefix1$2, app.roomwidth, app.roomheight, box + (ix + i2 - 1) * zoom.width, boy + (iy - 1) * zoom.height, 0)
                    IF ren_start = 0 THEN ren_start = AreaArr(ix + i2, iy)
                    Control(AreaArr(ix + i2, iy)).HasBorder = False
                    'diag
                    SetCaption (LabelTT), STR$(VAL(Caption(LabelTT)) + 1)
            NEXT: NEXT
        END IF

    ELSE
        'or do for alternative direction
        crunchct = scrvec.z - (zoom.height + Control(controlrange.min).Top) \ greater(1, zoom.height)

        crunched = 0
        REDIM ren_id(0) AS intpair
        FOR ix = 1 TO UBOUND(areaarr, 1)
            FOR iy = 1 TO UBOUND(areaarr, 2)
                IF iy <= crunchct * ABS(si2 - .5) THEN
                    GOTO minestrone
                ELSEIF (si2 + .5) * iy > UBOUND(areaarr, 2) - crunchct THEN
                    minestrone: 'label
                    FlameDestroy AreaArr(ix, iy)
                    IF crunched = 0 THEN crunched = iy
                    ps = UBOUND(ren_id) + 1
                    REDIM _PRESERVE ren_id(ps) AS intpair
                    ren_id(ps).a = ix: ren_id(ps).z = iy
                ELSE
                   Control(AreaArr(ix, iy)).Top=_
                      Control(AreaArr(ix, iy)).Top + scrvec.z
                END IF

        NEXT: NEXT
        '   then produce the number of widgets that got destroyed...
        IF crunched THEN
            diag_call_reg_2 ".."
            ren_start = 0
            box = Control(Area).Left: boy = Control(Area).Top
            i2 = (.5 - si2) * (UBOUND(areaarr, 2) - crunchct)

            FOR ix = 1 TO UBOUND(areaarr, 1)
                FOR iy = 1 TO crunchct
                    AreaArr(ix, iy + i2) = __UI_NewControl(__UI_Type_Frame, prefix1$2, app.roomwidth, app.roomheight, box + (ix - 1) * zoom.width, boy + (iy + i2 - 1) * zoom.height, 0)
                    Control(AreaArr(ix, iy + i2)).HasBorder = False
                    '...
                    IF ren_start = 0 THEN ren_start = AreaArr(ix, iy + i2)

                    'diag
                    SetCaption (LabelTT), STR$(VAL(Caption(LabelTT)) + 1)
            NEXT: NEXT
        END IF

    END IF
    SHARED prefix1$2, prefix2$2
    IF crunched THEN
        '... and alter their registry to be what content of AreaArr 's are not existing
        FOR i = ren_start TO UBOUND(control) '[not doing] -1 STEP 2 'select all new creation frame
            pi = AreaArr(ren_id(ps).a, ren_id(ps).z)
            SWAP Control(i), Control(pi)
            Control(pi).ID = pi
            '?
            '            nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2, app.roomwidth, app.roomheight, 1, 1, pi)

            nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2, app.roomwidth, app.roomheight, 1, 1, pi)

            'but don't bother:control(pi).name = control(pi).name+ltrim$ str$:control(pi).name = control(nameless).name+ltrim$ str$
            'u' set em clear

        NEXT i

    END IF


    '   if movement was leftward or upward (neg): subtract a quantity from each still existing AreaArr 's ID
    '   if movement was rightward or downward (neg):add a quantity to each still existing AreaArr 's ID

    '... re-filling frame widgets with PB widgets as we go

END IF
'  controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)
' adjust VirtualOffset .a.z
diag_call_reg_2 "adjs]"
'Cursor = Zupreme(Cursor)
adjust_scroll%% = True

END SUB


SUB RT__room (t AS room, d$)
DIM i AS _UNSIGNED INTEGER, size AS _UNSIGNED INTEGER, ftesize AS _UNSIGNED INTEGER
DIM m AS _MEM, pt AS _OFFSET, deco AS _BYTE
size = LEN(t): m = _MEM(t)
FOR i = 1 TO size
    deco = _CV(_BYTE, MID$(d$, i, 1))
    _MEMPUT m, m.OFFSET + i - 1, deco
NEXT i
END SUB

SUB Trans (a AS LONG, o AS intpair)
'as, usually, we'd need the .a or .z equivalent

o.a = a MOD roomboxsize.a
o.z = 1 + (a - 1) \ roomboxsize.a
'reverse calc is .a+roomboxsize.a * (.z-1)
END SUB
FUNCTION LocTrans& (id)
LocTrans = roomboxsize.a * (VirtualOffset.z - 1) + VirtualOffset.a - 1 + id - controlrange.min
END SUB

FUNCTION FailedZupreme& (This AS LONG)

'/Dyn1 = __UI_NewControl(__UI_Type_TextBox, "Dyn1", 100, 40, 32, 32, 0)
'/Control(Dyn1).Font = SetFont("segoeui.ttf", 14, "")
'/Dyn2 = __UI_NewControl(__UI_Type_PictureBox, "Dyn2", _WIDTH - 32, _HEIGHT - 32, 16, 16, 0)


'/Dyn1 = Zupreme&(Dyn1) ' ---> works
'/
'/ListBox1 = Zupreme&(ListBox1)
'/TrackBar1 = Zupreme&(TrackBar1)

'/ListBox1 = Zupreme&(ListBox1)
'/TrackBar1 = Zupreme&(TrackBar1)
'/Dyn1 = Zupreme&(Dyn1) ' ---> does NOT work to put the dynamic text box above the dynamic pic box



'a typical call would look like this: Button32=Zupreme(Button32)
startpoint = 101 ' the lowest control in the array
DIM i AS LONG, ub AS LONG, dummy AS __UI_ControlTYPE, str_dummy(1 TO 8) AS STRING

FOR i = UBOUND(Control) TO startpoint STEP -1
    IF Control(i).ID <> 0 THEN ub = i: IF This >= ub THEN Zupreme& = This: EXIT FUNCTION ELSE EXIT FOR
NEXT i
Zupreme& = ub
IF ub - This > 200 THEN: ' n$ = ErrorCage("awkwardly large z-upreming") 'optionally so
dummy = Control(This)
str_dummy(1) = Caption(This): str_dummy(2) = ToolTip(This): str_dummy(3) = Text(This): str_dummy(4) = Mask(This): str_dummy(5) = __UI_TempTexts(This): str_dummy(6) = __UI_TempCaptions(This): str_dummy(7) = __UI_TempTips(This): str_dummy(8) = __UI_TempMask(This)
FOR i = This TO ub - 1
    Control(i) = Control(i + 1): Caption(i) = Caption(i + 1): ToolTip(i) = ToolTip(i + 1): Text(i) = Text(i + 1): Mask(i) = Mask(i + 1)
    Control(i).ID = i: __UI_TempTexts(i) = __UI_TempTexts(i + 1): __UI_TempCaptions(i) = __UI_TempCaptions(i + 1): __UI_TempTips(i) = __UI_TempTips(i + 1): __UI_TempMask(i) = __UI_TempMask(i + 1)
NEXT i
Control(ub) = dummy: Control(ub).ID = ub
Caption(ub) = str_dummy(1): ToolTip(ub) = str_dummy(2): Text(ub) = str_dummy(3): Mask(ub) = str_dummy(4): __UI_TempTexts(ub) = str_dummy(5): __UI_TempCaptions(ub) = str_dummy(6): __UI_TempTips(ub) = str_dummy(7): __UI_TempMask(ub) = str_dummy(8)

FOR i = 1 TO UBOUND(control)
    pi = Control(i).ParentID
    IF pi = This THEN Control(i).ParentID = ub
    IF pi > This THEN IF pi <= ub THEN Control(i).ParentID = pi - 1
NEXT i
' Zupreme& = 'see above
END SUB



FUNCTION NextTime! (timedelta AS SINGLE)
nt! = (TIMER(.001) + timedelta) - (nt! \ 86400) * 86400 'just prevent out of bounds values when comparing TIMER output
NextTime! = nt!

END FUNCTION


SUB ADvalidate
'make sure controls don't over-flow the reg
'! app.roomwidth * zoom.width
'                    as in
'''areadim.a = lesser(areadim.a, Control(Area).Width / app.roomwidth / zoom.width / areadim.a)

''SetCaption Brush7, STR$(lesser(areadim.a, Control(Area).Width / 80 / 1))

'areadim.a = lesser(areadim.a, Control(Area).Width / 80 / 1)
'''SetCaption Brush8, STR$(lesser(areadim.z, Control(Area).Height / 53 / 1))
'areadim.z = lesser(areadim.z, Control(Area).Height / 53 / 1)

areadim.a = lesser(areadim.a + 1, Control(Area).Width / 80 / 1)
''SetCaption Brush8, STR$(lesser(areadim.z, Control(Area).Height / 53 / 1))
areadim.z = lesser(areadim.z + 1, Control(Area).Height / 53 / 1)
areadim.a = areadim.a - 1
areadim.z = areadim.z - 1

END SUB


FUNCTION lesser## (c1##, c2##): IF c1## < c2## THEN lesser## = c1## ELSE lesser## = c2##
END FUNCTION

FUNCTION greater## (c1##, c2##): IF c1## > c2## THEN greater## = c1## ELSE greater## = c2##

END FUNCTION


SUB SetFlag (fname AS _BYTE): fname = True: END SUB: SUB UnsetFlag (fname AS _BYTE): fname = False: END SUB


SUB PaintYou (targ AS LONG, tile_id AS INTEGER)
'
'SELECT CASE tile_id
'    CASE 0: LoadImage Control(targ), "res_mb/blnk.room.jpg"
'    CASE 1: LoadImage Control(targ), "res_mb/std.room.jpg"
'    CASE 2: LoadImage Control(targ), "res_mb/straight.jpg"
'END SELECT

BeginDraw targ


_PUTIMAGE , happres(tile_id)
EndDraw targ

END SUB

SUB MapResource (res_id AS LONG, ctrl_id AS LONG)
'transpation fn
IF res_id <= UBOUND(happres) THEN
    IF happres(res_id) < -1 THEN
        '' _FREEIMAGE Control(ctrl_id).HelperCanvas 'ifc
        Control(ctrl_id).HelperCanvas = _COPYIMAGE(happres(res_id), 33)
        Control(ctrl_id).PreviousValue = 0
END IF: END IF
END SUB


SUB WipeTile (This AS LONG)
kd& = _DEST: _DEST Control(This).HelperCanvas
PAINT (0, 0), _RGB32(0, 0, 0)
_DEST kd&


END FUNCTION

FUNCTION Readabunch$ (size AS LONG, hfile AS LONG)
'of bytes from a file
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + size
IF hfile THEN Readabunch$ = INPUT$(size, hfile)
END FUNCTION

FUNCTION Readalong& (hfile AS LONG)
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + LEN(a&)
IF hfile THEN Readalong& = CVL(INPUT$(4, hfile))
END FUNCTION



SUB CarryRoom (which AS LONG, targ AS LONG)
'target:library copy


' execute a swap, but later beh change to replace
SWAP Control(FindKid(which)), Control(FindKid(targ))
'making unnec:
'PaintYou FindKid(which), rooms(LocTrans  (which)).rmdesc
'PaintYou FindKid(targ), rooms(LocTrans  (targ)).rmdesc


'  local_a =  roomboxsize.a * (VirtualOffset.z - 1) + VirtualOffset.a - 1 + id - controlrange.min

SWAP rooms(LocTrans(which)), rooms(LocTrans(targ))



'swap which, lib_rooms_main((-1 + iy) - (roomboxsize.a +2)).rmdesc
'              lib_rooms_main
'! paths !!!


END SUB

SUB cancelrsz (errorspec AS _BYTE)
' & &  &  & &  &  & &  &  & &  &  & &  &  & &  &
'           Prevent dirtying of a layout by limiting resize
'
'                      errorspec = 1 : Width ineligible
'                      errorspec = 2 : Height ineligible
'                      errorspec = 3 : Both ineligible
hScreenmode = 0
SHARED __orgwidtht_Area, __orgheight_Area
approvedWidth = __orgwidtht_Area
approvedheight = __orgheight_Area
DIM hPrep AS LONG
SELECT CASE errorspec
    CASE 0 'approved
        ' make update base w & h
        'PlaceToScale True
        '
    CASE 1: hPrep = _NEWIMAGE(approvedWidth, _HEIGHT(hScreenmode), 32)
    CASE 2: hPrep = _NEWIMAGE(_WIDTH(hScreenmode), approvedheight, 32)
    CASE 3: hPrep = _NEWIMAGE(approvedWidth, approvedheight, 32)
END SELECT
_PUTIMAGE , hScreenmode, hPrep
SCREEN hPrep 'better: use safescreen

'x'_fullscreen :_deslay .35:_fullscreen _off

'if hScreenmode
'else
'end if

END SUB

SUB PathOrSwap




IF doing_slide THEN
    '
    IF Control(Dyn1).Left < lb1 THEN m_bump_x = lb1 - Control(Dyn1).Left: Control(Dyn1).Left = lb1: m_to_a = True
    IF Control(Dyn1).Top < lb2 THEN m_bump_y = lb2 - Control(Dyn1).Top: Control(Dyn1).Top = lb2: m_to_a = True
    IF Control(Dyn1).Left > ub1 THEN m_bump_x = ub1 - Control(Dyn1).Left: Control(Dyn1).Left = ub1: m_to_a = True
    IF Control(Dyn1).Top > ub2 THEN m_bump_y = ub2 - Control(Dyn1).Top: Control(Dyn1).Top = ub2: m_to_a = True
    IF m_to_a THEN _MOUSEMOVE __UI_DragX + m_bump_x, __UI_DragY + m_bump_y
END IF

END SUB




SUB nonworking
DIM dummy AS __UI_ControlTYPE
dummy.ID = __UI_NewControl(__UI_Type_Frame, "Frame1", Control(Frame1).Width, Control(Frame1).Height, Control(Frame1).Left, Control(Frame1).Top, 0)
SWAP Control(Frame1), dummy
SetCaption Frame1, ""
SWAP Control(dummy.ID).ID, Control(Frame1).ID
''Control(Frame1).ID = Frame1
__UI_DestroyControl dummy
' would this work in place of the ccursor destroy
END SUB




SUB diagnosticalinit

adjustzoom 0
app.formwidth = 1024
app.formheight = 768
app.roomwidth = 80: app.roomheight = 53
zoom.level = 2

END SUB

SUB diag_call_reg (msg$): END SUB
SUB diag_call_reg_2 (msg$)

'AddItem Scrolltrial2, msg$
Text(TTText) = Text(TTText) + msg$

END SUB


FUNCTION zoom.width ()
SHARED zoom_mults() AS SINGLE

STATIC extlevels_defined, levels_defined, zoom_mults() AS SINGLE
IF NOT extlevels_defined THEN
    levels_defined = 8
    ' DIM zoom_mults(levels_defined) AS SINGLE
    zoom_mults(1) = 2.5
    zoom_mults(2) = 1
    zoom_mults(3) = 1 / 2
    zoom_mults(4) = 1.3 / 3
    zoom_mults(5) = 1 / 3
    zoom_mults(6) = 1.4 / 4
    zoom_mults(7) = 1 / 4
    zoom_mults(8) = 1.5 / 5
extlevels_defined = True: END IF

zoom.width = zoom_mults(zoom.level)
SHARED zoom.crit
IF zoom.crit THEN zoom.width = 1

END FUNCTION
'zoom.width = app.roomwidth * zoom.level: END FUNCTION

FUNCTION zoom.height ()
STATIC extlevels_defined, levels_defined, zoom_mults() AS SINGLE
SHARED zoom_mults() AS SINGLE
IF NOT extlevels_defined THEN
    levels_defined = 8
    '  DIM zoom_mults(levels_defined) AS SINGLE
    zoom_mults(1) = 2.5
    zoom_mults(2) = 1
    zoom_mults(3) = 1 / 2
    zoom_mults(4) = 1.3 / 3
    zoom_mults(5) = 1 / 3
    zoom_mults(6) = 1.4 / 4
    zoom_mults(7) = 1 / 4
    zoom_mults(8) = 1.5 / 5
extlevels_defined = True: END IF
''adjustzoom (factor)
zoom.height = zoom_mults(zoom.level)
SHARED zoom.crit
IF zoom.crit THEN zoom.height = 1
END FUNCTION

FUNCTION RMBstate%%: RMBstate%% = __UI_MouseButton2
END FUNCTION

FUNCTION ErrorCage$ (msg$)
STATIC Errorz AS STRING
ErrorCage = Errorz
Errorz = Errorz + msg$

END SUB

SUB spotchange (id, res_id)
PaintYou FindKid(id), rooms(res_id).rmdesc

'draw paths next


END SUB

SUB prot_setZoomValue (zscl AS SINGLE)
diag_call_reg "pzv" + LTRIM$(STR$(zscl))


'first sync delta canvas to res() ; repeat for paths ; and again, for

'get center offset from area's corner offset, mutiply by the factor and derive corner offset from there again

'check corners with offset

'derive new scroll position - ex, if a factor is 2/3 then 3/2 are now to be shown, and left offscreen part, mulxed by factor gains (1-3/2) /2 of what's shown. resulting sum if positive divved by original left offscreen part makes new scroll pos





END SUB



SUB InVisiblate

'hide the unimplemented bits, so they're out of the way

'Control(ZoomBar).Hidden = True

Control(ExpandBT).Hidden = True
Control(ZoomBar).Hidden = True
Control(Frame2).Hidden = True
Control(Frame3).Hidden = True

END SUB
