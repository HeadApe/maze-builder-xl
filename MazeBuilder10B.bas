': This program was generated by
': InForm - GUI system for QB64 - Beta version 3
': Fellippe Heitor, 2016 - fellippe@qb64.org - @fellippeheitor
'-----------------------------------------------------------

': Controls' IDs: ------------------------------------------------------------------
DIM SHARED __drag_complete AS _BYTE
DIM SHARED MazeBuilder AS LONG
DIM SHARED Ccursor AS LONG
DIM SHARED Frame3 AS LONG
DIM SHARED Frame2 AS LONG
DIM SHARED Frame1 AS LONG 'over-frame of 2 and 3
DIM SHARED Brush1 AS LONG
DIM SHARED Brush2 AS LONG
DIM SHARED Brush3 AS LONG
DIM SHARED Brush4 AS LONG
DIM SHARED Brush5 AS LONG
DIM SHARED Brush6 AS LONG
DIM SHARED Brush7 AS LONG
DIM SHARED Brush8 AS LONG
DIM SHARED Brush9 AS LONG
DIM SHARED Brush10 AS LONG
DIM SHARED Brush11 AS LONG
DIM SHARED Brush12 AS LONG
DIM SHARED Area AS LONG
DIM SHARED StandardBT AS LONG
DIM SHARED SlowingBT AS LONG
DIM SHARED LabelTT AS LONG
DIM SHARED TTText AS LONG
DIM SHARED HardBT AS LONG
DIM SHARED KeyedBT AS LONG
DIM SHARED OneWayBT AS LONG
DIM SHARED ZoomBar AS LONG
DIM SHARED expandLB AS LONG
DIM SHARED EnterBT AS LONG
DIM SHARED LoadBT AS LONG
DIM SHARED SaveBT AS LONG

DIM SHARED Scrolltrial AS LONG
DIM SHARED Scrolltrial2 AS LONG
DIM SHARED ExpandBT AS LONG
DIM SHARED TopRB AS LONG '
DIM SHARED BottomRB AS LONG
DIM SHARED RightRB AS LONG
DIM SHARED LeftRB AS LONG
DIM SHARED ExpandBar AS LONG
DIM SHARED ApplyBT AS LONG

DIM SHARED BrushLevelList AS LONG
DIM SHARED Cursor AS LONG

CONST __uix_unfiltered = -2
REDIM SHARED uix_sweeplist(0) AS LONG

' MazeBuilder Base Types
'  * * * * * please copy this into your target application
TYPE intpair
    a AS INTEGER
    z AS INTEGER
END TYPE
TYPE singpair
    sa AS SINGLE
    sz AS SINGLE
END TYPE
CONST None = 0, Chamb = 1, Cave = 2, MajorTreasure = 7, miNorTreasure = 8, Market = 5
CONST Fount = 3, Relic = 6, Shrine = 4, Entry = 9
CONST Tunnel = 20, Slide = 30, Slowing = 40, Guarded = 50

'bla!
REDIM SHARED My.sweeplist(0) AS LONG


TYPE room
' firsttypeelement AS _UNSIGNED _BYTE
    now AS INTEGER ' as unique index
    rmdesc AS _BYTE
    isof AS INTEGER
    rmelab AS STRING * 8
    ' ^ possible ideas:
    ' * feature of merged path * idx of a room descr * unique treasure * class name
    exit1 AS INTEGER
    exit2 AS INTEGER
    exit3 AS INTEGER
    exit4 AS INTEGER
    exit5 AS INTEGER
    exit6 AS INTEGER
    exit7 AS INTEGER
    exit8 AS INTEGER
END TYPE
TYPE roomsup
    offset AS intpair 'internal calc
    customoffset AS intpair
    'clock face positioning of the tunnel graphics
    exit1 AS _BYTE
    exit2 AS _BYTE
    exit3 AS _BYTE
    exit4 AS _BYTE
    exit5 AS _BYTE
    exit6 AS _BYTE
    exit7 AS _BYTE
    exit8 AS _BYTE
END TYPE
TYPE MazebuildProps
    formwidth AS INTEGER
    formheight AS INTEGER
    roomwidth AS INTEGER
    roomheight AS INTEGER
    brush AS INTEGER

END TYPE
TYPE InputControl
    dragstart AS SINGLE
    dragcontext AS LONG
    dragon AS _BYTE
    dclickstart AS SINGLE
END TYPE

CONST res_room = 1, res_cave = 2, res_foun = 3, res_shri = 4
CONST dblclick_thresh = .35 'seconds that may pass between clicks
CONST drag_thresh = .55 'seconds that may pass before a mousedown is treated as a drag

DIM zoom_mults(8) AS SINGLE

DIM SHARED app AS MazebuildProps, appctl AS InputControl
DIM SHARED AreaCursor AS InputControl
DIM SHARED FoundRes(20) AS STRING, happres(20) AS LONG
DIM SHARED scroll.top, scroll.left, zoom.value ', zoom.width, zoom.height

redim SHARED rooms(0) AS room, paths(0) AS room, _
        visualfacts(0  ) AS roomsup, roomboxsize as intpair

REDIM SHARED lib_rooms_main(0) AS room, lib_roomsup_main(0) AS room

REDIM SHARED AreaArr(0, 0) AS LONG, areadim AS intpair
DIM SHARED VirtualOffset AS intpair
DIM SHARED controlrange.max AS LONG, controlrange.min AS LONG

LoadResources

'$INCLUDE:'InForm\InForm.ui'
'$INCLUDE:'InForm\xp.uitheme'
'$INCLUDE:'MazeBuilder10B.frm'

': Event procedures: ---------------------------------------------------------------
SUB __UI_BeforeInit

END SUB

SUB __UI_OnLoad


FOR i = 1 TO 5
    AddItem BrushLevelList, STR$(i)
NEXT


InVisiblate
Cursor = Zupreme(Cursor)
BeginDraw Cursor
DIM this AS __UI_ControlTYPE
CLS , &H606868C0
Control(Cursor).HasBorder = False
this = Control(Cursor)

LINE (this.Width * .2, this.Height \ 2)-STEP(this.Width * .6, 0), &HFFFF3F3F
CIRCLE STEP(4, 0), 5, &HFFFF3F3F: CIRCLE STEP(-8 - this.Width * .6, 0), 5, &HFFFF3F3F
LINE (this.Width \ 2, this.Height * .2)-STEP(0, this.Height * .6), &HFFFF3F3F
CIRCLE STEP(0, 4), 5, &HFFFF3F3F: CIRCLE STEP(0, -8 - this.Height * .6), 5, &HFFFF3F3F
EndDraw Cursor


Control(Frame1).Hidden = True

'frame doesn't work for me, try picbox
DIM holder_x AS __UI_ControlTYPE
holder_x = Control(Ccursor)
__UI_DestroyControl Control(Ccursor)
Ccursor = __UI_NewControl(__UI_Type_PictureBox, "Ccursor", holder_x.Width, holder_x.Height, holder_x.Left, holder_x.Top, 0)
BeginDraw Ccursor
CLS , &H00FFFFFF

FOR i = 1 TO 7
    LINE (i, i)-(Control(Ccursor).Width - i - 1, Control(Ccursor).Height - i - 1), _RGB32(164, 76, 0), B
NEXT i
Control(Ccursor).BackColor = Control(Ccursor).BackColor AND &H00FFFFFF
EndDraw Ccursor
''Control(Area).Width = 30: Control(Area).Height = 30


'Various preemptive inits
PlaceToScale True

'Set up zoomer and scroller(s)
Control(Scrolltrial2).HasBorder = True 'False
Control(Scrolltrial2).Disabled = False
FOR i = 1 TO 48
    AddItem Scrolltrial2, "HH. H"
NEXT i

Control(Scrolltrial).Disabled = False
Control(Area).Disabled = False

Control(Frame2).Top = Control(ExpandBT).Top + Control(Frame2).Height
Control(Frame2).Left = Control(ExpandBT).Left - 34 - Control(Frame2).Width
Control(Frame3).Top = Control(expandLB).Top + Control(Frame3).Height * 2
Control(Frame3).Left = Control(expandLB).Left - 34 - Control(Frame3).Width
Control(Frame2).HasBorder = False
Control(Frame3).HasBorder = False
Control(RightRB).Value = True
Control(BottomRB).Value = True

' SAMPLE- Set up blank area
Control(Area).Width = Control(Area).Width - 75

'!examp -- actually set virtual dims 1st
areadim.a = 9: areadim.z = areadim.a
areadim.a = 16 ': areadim.z = 11


'virtual components
REDIM rooms(areadim.a * areadim.z) AS room
REDIM visualfacts(areadim.a * areadim.z) AS roomsup

ADvalidate

'!examp
roomboxsize.a = areadim.a: roomboxsize.z = areadim.z:

'cleanup (as needed)
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        px = AreaArr(ix, iy)
        IF px THEN
            noti = FindKid(px): IF noti > 0 THEN __UI_DestroyControl Control(noti)
            __UI_DestroyControl Control(px) ' mean for the control to have contiguous indices
        END IF
NEXT: NEXT
ERASE AreaArr: REDIM AreaArr(areadim.a, areadim.z) AS LONG


'AreaArr(ix, iy)
' offset a buncha new widgets from the picturebox's vertex
box = Control(Area).Left: boy = Control(Area).Top
SHARED prefix1$2, prefix2$2: prefix1$2 = "^A": prefix2$2 = "AA"
FOR ix = 1 TO areadim.a ' UBOUND(areaarr, 1)
    FOR iy = 1 TO areadim.z ' UBOUND(areaarr, 2)
        ic& = ic& + 1
        '  AreaArr(ix, iy) = __UI_NewControl(__UI_Type_PictureBox, "AA" + LTRIM$(STR$(ic&)), zoom.width, zoom.height, (ix - 1) * zoom.width, (iy - 1) * zoom.height, Area)
        '  AreaArr(ix, iy) = __UI_NewControl(__UI_Type_Frame, "^A" + LTRIM$(STR$(ic&)), zoom.width, zoom.height, box + (ix - 1) * zoom.width, boy + (iy - 1) * zoom.height, 0)
        'at unscaled size here
        SHARED zoom.crit

        ' diag
        IF (ix - 1) * app.roomwidth * zoom.width = 0 THEN app.roomwidth = 80: zoom.crit = True: app.roomheight = 53:


        AreaArr(ix, iy) = __UI_NewControl(__UI_Type_Frame, prefix1$2 + LTRIM$(STR$(ic&))_
            , app.roomwidth* zoom.width - 1, app.roomheight* zoom.height-1,_
            box + (ix - 1) * app.roomwidth * zoom.width, boy + (iy - 1) * app.roomheight * zoom.height, 0)
        Control(AreaArr(ix, iy)).HasBorder = False
        Control(AreaArr(ix, iy)).BackColor = Control(AreaArr(ix, iy)).BackColor AND &H00FFFFFF
        'u' set em clear
NEXT: NEXT: ic& = 0
controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)
'now same
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        ic& = ic& + 1
        '?"        nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 1, 1, AreaArr(ix, iy))
        'is !THIS why?         nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 1, 1, AreaArr(ix, iy))
        nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2 + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 0, 0, AreaArr(ix, iy))


        IF Control(AreaArr(ix, iy)).Value < 1 THEN Control(AreaArr(ix, iy)).Value = 1

        'u' Control(AreaArr(ix, iy)).Hidden = True
        IF ix MOD 2 THEN 'ix <= 2 AND iy <= 3 THEN

            spotchange FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc

            PaintYou FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc
        ELSE
            'don't it work?
            ' MapResource 0, nameless
            '  MapResource 0, FindKid(AreaArr(ix, iy))
            PaintYou FindKid(AreaArr(ix, iy)), rooms((-1 + iy) * roomboxsize.a + ix).rmdesc

        END IF


NEXT: NEXT



VirtualOffset.a = 1: VirtualOffset.z = 1

Cursor = Zupreme(Cursor)
'?consider minimum creation requirements when calling __UI_NewControl
'?for frame, .VAlign
'for button, .Font


END SUB

SUB __UI_BeforeUpdateDisplay
'   ^ &)     ^ &)      ^ &)     ^ &)      ^ &)     ^ &)      ^ &)     ^ &)      ^ &)     ^ &)

' detect drag
'orig
IF AreaCursor.dragstart > 0 THEN IF TIMER(.001) > AreaCursor.dragstart AND ABS(AreaCursor.dragstart - TIMER) < 50000 THEN AreaCursor.dragon = True: AreaCursor.dragstart = -1

'' misc


'''' detect hovers    ''''

DIM pp AS intpair, pq AS intpair

pp.a = __UI_MouseLeft: pp.z = __UI_MouseTop

pq.a = pp.a: pq.z = pp.z
CALL SweepControls(pp, pq)
REDIM My.sweeplist(UBOUND(uix_sweeplist)) AS LONG
FOR i = UBOUND(uix_sweeplist) TO 1 STEP -1: My.sweeplist(i) = uix_sweeplist(i): NEXT i
REDIM uix_sweeplist(0) AS LONG

'STATIC ms_type&& ' doesn't srike the rite aesthetic
'IF Feel = Area THEN ms_type&& = ms_type&& XOR -1: IF ms_type&& THEN _MOUSEHIDE: _MOUSESHOW "TOPLEFT_BOTTOMRIGHT" ELSE _MOUSEHIDE: _MOUSESHOW "TOPRIGHT_BOTTOMLEFT" 'did not really work as expected
IF Feel <> Area THEN _MOUSESHOW "DEFAULT"

'''''''' work the area
' moved to: _Click

'got any single do flags?
SHARED fSingle_area_click_done AS _BYTE
fSingle_area_click_done = False

STATIC newRMBstate AS _BYTE, prevRMBstate AS _BYTE
prevRMBstate = newRMBstate: newRMBstate = RMBstate


IF NOT (prevRMBstate IMP newRMBstate) THEN
    '  DIM pp AS intpair, pq AS intpair
    ''pp.a = __UI_MouseLeft - Control(Feel).Left: pp.z = __UI_MouseTop - Control(Feel).Top
    pp.a = __UI_MouseLeft: pp.z = __UI_MouseTop
    ' Pull out and activate tile Frame if one has been clicked
    pq.a = pp.a + 1: pq.z = pp.z + 1
    CALL SweepControls(pp, pq)
    '    FOR g = 1 TO UBOUND(uix_sweeplist)
    FOR g = 1 TO UBOUND(My.sweeplist)
        '       AreaClick uix_sweeplist(g)
        AreaClick My.sweeplist(g)
    NEXT g
    '  REDIM uix_sweeplist(0) AS LONG

END IF 'onetime rmb hand-o




END SUB

SUB __UI_BeforeUnload

END SUB


SUB AreaClick (id AS LONG)
SELECT CASE id
    CASE controlrange.min TO controlrange.max
        diag_call_reg "fc": diag_call_reg CHR$(1)

        'translate control id to the rooms(id) ; wish for an easier way of doing this
        local_a = VirtualOffset.a - 1 + roomboxsize.a * (VirtualOffset.z - 1) + id - controlrange.min
        '!! ^ check if you're not off by 1
        rooms(local_a).rmdesc = Chamb 'app.brush
        spotchange id, local_a
        __UI_ForceRedraw = True

        spotchange id, local_a
        __UI_ForceRedraw = True
END SELECT
END SUB

SUB __UI_MouseUp (id AS LONG)
SHARED DoMoveCursor: DoMoveCursor = False
SHARED __drag_complete AS _BYTE, __cross_dispatch_top
IF __cross_dispatch_top THEN GOTO top_select:

IF AreaCursor.dragon THEN __drag_complete = True: AreaCursor.dragon = False


IF appctl.dclickstart > 0 THEN IF appctl.dclickstart < TIMER(.001) AND ABS(appctl.dclickstart - TIMER) < 50000 THEN we_are_double = True: appctl.dclickstart = NextTime(dblclick_thresh)

IF we_are_double THEN ' doesn't work for nuts
    lib_rooms_main(local_a).rmdesc = Shrine 'app.brush

    spotchange id, local_a
    __UI_ForceRedraw = True
    ' / & & & end-double click handler
    we_are_double = False
ELSE
    IF __drag_complete THEN 'OR AreaCursor.dragon THEN


        '--> here
        'FOR i = 1 TO UBOUND(my.sweeplist)
        '    IF Control(My.sweeplist(i)).Type = __UI_Type_Frame THEN cin = My.sweeplist(i)
        'NEXT i

        'CarryRoom AreaCursor.dragcontext, cin


        '__drag_complete = False '-- this is saved for the _Click handler sub
    END IF

    GOTO area_handler:
END IF



top_select:

SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12
        'move cursor

        Control(Ccursor).Hidden = False
        '   Control(Ccursor).BorderColor = _RGBA32(255, 180, 0, 255)
        Control(Ccursor).Top = Control(id).Top - 9
        Control(Ccursor).Left = Control(id).Left - 9
        '  __UI_ForceRedraw = True


    CASE Area

    CASE ApplyBT
        Control(Frame1).Hidden = True
        Control(ExpandBT).Hidden = False: Control(ExpandBT).Disabled = False
        Control(ZoomBar).Disabled = False
        __UI_ForceRedraw = True
    CASE Button13, Button14, Button15, Button16, Button17
        Control(Ccursor).Hidden = False
        '   Control(Ccursor).BorderColor = _RGBA32(255, 180, 0, 255)
        Control(Ccursor).Top = Control(BrushLevelList).Top + 4
        Control(Ccursor).Left = Control(BrushLevelList).Left + 4

    CASE TextTT

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT
        Control(Frame1).Hidden = False
        ''' Control(Frame3).Hidden = False

        '        Control(Ccursor).Hidden = False
        '        Control(Frame).Hidden = False
        Control(ExpandBT).Hidden = True: Control(ExpandBT).Disabled = True
        Control(ZoomBar).Disabled = True
        __UI_ForceRedraw = True

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

END SELECT
'diag
'IF __cross_dispatch_top THEN __cross_dispatch_top = False: EXIT SUB

IF __UI_MouseTop <= Control(Area).Top + Control(Area).Height THEN
    IF __UI_MouseTop >= Control(Area).Top AND __UI_MouseLeft <= Control(Area).Left + Control(Area).Width AND __UI_MouseLeft >= Control(Area).Left THEN
        area_handler:
        SHARED fSingle_area_click_done AS _BYTE
        IF NOT fSingle_area_click_done THEN 'ensure only one of these just in case
            '  DIM pp AS intpair, pq AS intpair
            ''pp.a = __UI_MouseLeft - Control(Feel).Left: pp.z = __UI_MouseTop - Control(Feel).Top
            pp.a = __UI_MouseLeft: pp.z = __UI_MouseTop
            ' Pull out and activate tile Frame if one has been clicked
            pq.a = pp.a + 1: pq.z = pp.z + 1
            '  CALL SweepControls(pp, pq)

            FOR g = 1 TO UBOUND(my.sweeplist)
                '            FOR g = 1 TO UBOUND(uix_sweeplist)
                '                AreaClick uix_sweeplist(g)
                AreaClick My.sweeplist(g)
            NEXT g
            REDIM uix_sweeplist(0) AS LONG
            fSingle_area_click_done = True
        END IF
    END IF
ELSE

END IF

END SUB

SUB __UI_MouseEnter (id AS LONG)
SELECT CASE __UI_BelowHoveringID
    CASE controlrange.min TO controlrange.max
        '   Control(Cursor).Left = Control(__UI_BelowHoveringID).Left - 6
        '   Control(Cursor).Top = Control(__UI_BelowHoveringID).Top - 6

        ' DIM this AS __UI_ControlTYPE

        STATIC this_stat
        IF this_stat = 0 THEN this_stat = _NEWIMAGE(80, 60, 32)
        _DEST this_stat
        'CLS , 0
        LINE (this.Width * .2, this.Height \ 2)-STEP(this.Width * .6, 0), &HFFFF3F3F
        CIRCLE STEP(4, 0), 5, &HFFFF3F3F: CIRCLE STEP(-8 - this.Width * .6, 0), 5, &HFFFF3F3F
        LINE (this.Width \ 2, this.Height * .2)-STEP(0, this.Height * .6), &HFFFF3F3F
        CIRCLE STEP(0, 4), 5, &HFFFF3F3F: CIRCLE STEP(0, -8 - this.Height * .6), 5, &HFFFF3F3F
        DIM cann(80 * 60 + 9) AS LONG
        GET (0, 0)-(79, 59), cann()
        _DEST 0
        BeginDraw Cursor
        PUT (Control(__UI_BelowHoveringID).Left - Control(controlrange.min).Left, Control(__UI_BelowHoveringID).Top - Control(controlrange.min).Top), cann(), _CLIP XOR
        EndDraw Cursor


END SELECT
SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame2

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

END SELECT
END SUB

SUB __UI_MouseLeave (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE Button15

    CASE Button16

    CASE Button17

    CASE TextTT

    CASE ZoomBar

    CASE Frame1, Frame2, Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT, LoadBT, SaveBT

    CASE LabelTT

    CASE ZoomBar

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_FocusIn (id AS LONG)
'SELECT CASE id
'    CASE MazeBuilder

'    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
'        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

'    CASE Area

'    CASE Area

'    CASE ApplyBT

'    CASE Button13

'    CASE Button14

'    CASE TextTT

'    CASE Button15

'    CASE Button16

'    CASE Button17

'    CASE ZoomBar

'    CASE Frame1

'    CASE Frame2

'    CASE Frame3

'    CASE Ccursor

'    CASE ExpandBT

'    CASE expandLB

'    CASE TopRB

'    CASE BottomRB

'    CASE RightRB

'    CASE LeftRB

'    CASE EnterBT

'    CASE LoadBT

'    CASE SaveBT

'    CASE LabelTT

'    CASE ZoomBar

'    CASE controlrange.min TO controlrange.max

'END SELECT
END SUB

SUB __UI_FocusOut (id AS LONG)
'SELECT CASE id
'    CASE MazeBuilder

'    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
'        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

'    CASE Area

'    CASE Area

'    CASE ApplyBT

'    CASE Button13

'    CASE Button14

'    CASE TextTT

'    CASE Button15

'    CASE Button16

'    CASE Button17

'    CASE ZoomBar

'    CASE Frame1

'    CASE Frame2

'    CASE Frame3

'    CASE Ccursor

'    CASE ExpandBT

'    CASE expandLB

'    CASE TopRB

'    CASE BottomRB

'    CASE RightRB

'    CASE LeftRB

'    CASE EnterBT

'    CASE LoadBT

'    CASE SaveBT

'    CASE LabelTT

'    CASE ZoomBar

'    CASE controlrange.min TO controlrange.max
'END SELECT
END SUB

SUB __UI_MouseDown (id AS LONG)


SHARED DoMoveCursor: DoMoveCursor = True

FOR i = 1 TO UBOUND(my.sweeplist)
    IF Control(My.sweeplist(i)).Type = __UI_Type_Frame THEN cin = My.sweeplist(i)
NEXT i

AreaCursor.dragcontext = cin
AreaCursor.dragstart = NextTime(drag_thresh)
appctl.dclickstart = NextTime(dblclick_thresh)
'        AreaCursor.dragcontext = id 'sellyID
'        AreaCursor.dragcontext = Control(FindKid(__UI_BelowHoveringID)).ParentID


SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar
END SELECT

'''''u partial condit'n
''''IF __UI_MouseTop < Control(Area).Height AND __UI_MouseLeft < Control(Area).Left + Control(Area).Width THEN
''''    AreaCursor.dragcontext = (FindKid(__UI_BelowHoveringID))
''''    IF Control(AreaCursor.dragcontext).Type <> __UI_Type_Frame THEN AreaCursor.dragcontext = Control(AreaCursor.dragcontext).ParentID
''''    AreaCursor.dragstart = NextTime(drag_thresh)

''''END IF

END SUB

SUB __UI_Click (id AS LONG)

'only doing this ?: ---------

SHARED __drag_complete AS _BYTE
IF __drag_complete THEN __drag_complete = False: EXIT SUB 'don't mishandle a dragdrop


SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

    CASE controlrange.min TO controlrange.max

        '?>        Control(Scrolltrial).Value = 1 + id - controlrange.min


END SELECT

'xxxx AreaCursor.dragon = False: AreaCursor.dragstart = -1
END SUB

SUB __UI_KeyPress (id AS LONG)

SELECT CASE id
    CASE MazeBuilder

    CASE Brush1, Brush2, Brush3, Brush4, Brush5,  Brush6,_
        Brush7, Brush8, Brush9, Brush10, Brush11, Brush12

    CASE Area

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Ccursor

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE ZoomBar

    CASE controlrange.min TO controlrange.max
END SELECT

'SUB __UI_KeyPress (id AS LONG)
SHARED __cross_dispatch_top
__cross_dispatch_top = True ' about to fire an event sub, make it known its an artificial call

asc_rng$ = CHR$(lesser(255, greater(1, 0 - __UI_KeyHit)))
SELECT CASE LCASE$(asc_rng$)
    '!! simple, change click to __UI_MouseUp
    CASE "b": app.brush = Chamb
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "c": app.brush = Cave
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "n", "o": app.brush = MajorTreasure
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "m": app.brush = miNorTreasure
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "k": app.brush = Market
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "h": app.brush = Fount
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "i": app.brush = Relic
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "l", "v": app.brush = Entry
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE "y": app.brush = Shrine
        __UI_MouseUp Control(Brush1).ID + app.brush - 1
    CASE ELSE: __cross_dispatch_top = False
END SELECT


'undo-able follows
if  __UI_mousetop > Control(area).top AND __UI_mousetop <=  Control(Area).top + Control(area).Height and _
 __UI_mouseleft > Control(area).Left AND __UI_mouseleft <= Control(Area).Left + Control(Area).Width  then
    IF LCASE$(asc_rng$) = "r" THEN

        'doing add single row
        'need the frameid - of the
        aid = Control(SellyID).ID

        DIM pp AS intpair, pq AS intpair
        pp.a = Control(Area).Left: pp.z = __UI_MouseTop: pq.a = __UI_MouseLeft: pq.z = __UI_MouseTop
        aid = ScanControls(pp, pq, __UI_Type_Frame, 1)


        '  areadim.z is not affected
        ''  downdist = Control(aid).Height
        ''  updist = Control(controlrange.max).Top - Control(aid).Top
        FOR i = controlrange.max TO aid STEP -1
            ''            Control(i).Top = Control(i).Top + downdist
            IF i + areadim.a > controlrange.max THEN
                '' __UI_DestroyControl Control(FindKid&(i))
                WipeTile FindKid&(i): Control(FindKid&(i)).Name = "-A" + STRING$(i, "a")

            ELSE
                ChangeParent FindKid&(i), i + areadim.a
                'now reflect the change in parent name
                Control(i + areadim.a).Name = Control(i).Name

            END IF
        NEXT i
        'FOR i = controlrange.max - areadim.a + 1 TO controlrange.max
        '    Control(i).Top = Control(i).Top - updist
        'NEXT i

        REDIM _PRESERVE rooms(UBOUND(rooms) + roomboxsize.a) AS room, visualfacts(UBOUND(visualfacts) + roomboxsize.a) AS roomsup
        REDIM _PRESERVE paths(LBOUND(paths) + roomboxsize.a TO UBOUND(paths) + roomboxsize.a) AS room
        DIM dummy1 AS roomsup, dummy AS room
        FOR i = UBOUND(visualfacts) TO UBOUND(rooms) STEP -1 ' visualfacts has different bounds, start adjusting these
            visualfacts(i) = visualfacts(i - roomboxsize.a)
        NEXT i
        FOR i = i TO i - roomboxsize.a STEP -1: visualfacts(i) = dummy1: NEXT i
        '  DIM found_z AS intpair: Trans bid, found_z  :bid=0
        'try:
        found_z.z = ot + aid \ greater(1, areadim.a)
        '''=roomboxsize.a  (ot-1)

        '   bid = VAL(RIGHT$(Control(aid).Name, LEN(Control(aid).Name) - 2)) 'for __UI_Type_Frame



        ireach = 1 + roomboxsize.a * found_z.z
        FOR i = roomboxsize.a * roomboxsize.z TO ireach - roomboxsize.a STEP -1 'iterate the moved portion of rooms() resource!
            IF i < ireach THEN
                IF rooms(i).isof <> 0 THEN
                    IF rooms(i).isof < i THEN
                        'do nothing, move nothing

                END IF: END IF

                IF found_z.z > 1 THEN IF rooms(i - roomboxsize.a).isof <> 0 THEN IF rooms(i - roomboxsize.a).isof = i THEN rooms(i + roomboxsize.a) = rooms(i): rooms(i) = dummy:: visualfacts(i + roomboxsize.a) = visualfacts(i): visualfacts(i) = dummy1:: SWAP rooms(i - roomboxsize.a), rooms(i): SWAP visualfacts(i - roomboxsize.a), visualfacts(i): descended = True
                'if descended "-A"
            ELSE
                'generally'
                rooms(i + roomboxsize.a) = rooms(i)
                visualfacts(i + roomboxsize.a) = visualfacts(i)
                '': visualfacts(i) = dummy1::SWAP rooms(i - roomboxsize.a), rooms(i): SWAP visualfacts(i - roomboxsize.a), visualfacts(i)


            END IF 'don't forget to mirror with roomsup

        NEXT i
        roomboxsize.z = roomboxsize.z + 1

        ' also grab new lib
    END IF '~
    IF LCASE$(asc_rng$) = "t" THEN
        'also grab new lib
    END IF
END IF

END SUB

SUB __UI_TextChanged (id AS LONG)
SELECT CASE id
    CASE TextTT

END SELECT
END SUB

SUB __UI_ValueChanged (id AS LONG)
SHARED scrolltr_oldval, scrolltr_oldval2
SELECT CASE id
    CASE Scrolltrial
        Control(Scrolltrial).Value = _CEIL(Control(Scrolltrial).Value)
        Horz = 1

        ok = adjust_scroll(Horz, Control(Scrolltrial).Value - scrolltr_oldval)
        ' IF ok THEN scrolltr_oldval = Control(Scrolltrial).Value ELSE Control(Scrolltrial).Value = scrolltr_oldval
    CASE Scrolltrial2
        Vert = 2
        ok = adjust_scroll(Vert, Control(Scrolltrial2).Value \ 3 - scrolltr_oldval2)
        IF ok THEN scrolltr_oldval2 = Control(Scrolltrial2).Value ELSE Control(Scrolltrial2).Value = scrolltr_oldval2
    CASE ExpandBar

    CASE ZoomBar
    CASE BrushLevelList
        prot_setZoomValue Control(id).Value



END SELECT
END SUB

SUB ChangeParent (c1 AS LONG, c2 AS LONG)
Control(c1).ParentID = Control(c2).ID
Control(c1).ParentName = Control(c2).Name
diag_call_reg "-= pc!=-"
END SUB



SUB FlameDestroy (This AS LONG)
FOR i& = 1 TO UBOUND(control)
    IF Control(i&).ParentID = Control(This).ID THEN __UI_DestroyControl Control(i&)
NEXT: __UI_DestroyControl Control(This)
END SUB

FUNCTION ScanControls& (from AS intpair, too AS intpair, c_type AS LONG, _
 helperindex AS LONG) 'it would seem useful to get the id of a control given an area;


DIM i AS LONG, j AS _INTEGER64, k AS _INTEGER64, m AS _INTEGER64, n AS _INTEGER64,_
    qual AS _BYTE, qual1 AS _BYTE, qual2 AS _BYTE, qual3 AS _BYTE, qual4 AS _BYTE, qual5 AS _BYTE
unfiltered = __uix_unfiltered

ub = UBOUND(Control): helperindex = lesser(ub, helperindex)

FOR si = greater(1, helperindex) TO UBOUND(Control) + helperindex
    IF 0 < helperindex THEN i = greater(1, si MOD ub) ELSE i = si
    IF Control(i).Type = c_type THEN
        fusilli:
        '         dealing with top right and bottom left corners
        k = Control(i).Top: j = Control(i).Left + Control(i).Width ' :  k  j
        n = Control(i).Top + Control(i).Height: m = Control(i).Left '  :  n  m
        DO
            IF k >= from.z THEN
                IF k <= too.z THEN
                    IF j >= from.a THEN
                        IF j <= too.a THEN
                            qual1 = True: EXIT DO
            END IF: END IF: END IF: END IF
            IF n >= from.z THEN
                IF n <= too.z THEN
                    IF m >= from.a THEN
                        IF m <= too.a THEN
                            qual2 = True: EXIT DO
            END IF: END IF: END IF: END IF
            IF from.z >= k THEN
                IF from.z <= n THEN
                    IF from.a >= m THEN
                        IF from.a <= j THEN
                            qual3 = True: EXIT DO
                END IF: END IF: END IF
            ELSE 'from.z < k
                IF too.z > n THEN
                    IF from.a > m THEN
                        IF too.a < j THEN
                            qual5 = True: EXIT DO
                END IF: END IF: END IF

            END IF
            IF too.z <= n THEN
                IF too.z >= k THEN

                    IF too.a >= m THEN
                        IF too.a <= j THEN
                            qual4 = True: EXIT DO
                END IF: END IF: END IF
                ' too.z < n
                IF from.z > k THEN
                    IF too.a > j THEN
                        IF from.a < m THEN
                            qual5 = True: EXIT DO
            END IF: END IF: END IF: END IF
            EXIT DO
        LOOP
        IF qual1 OR qual2 OR qual3 OR qual4 OR qual5 THEN qual = True: EXIT FOR
        '            IF  Control(x).Top+ THEN
        '            ELSE '1st check

        '            END IF



        '             1  1             1  1
        '              2    2        2      2
        '             1  1             1  1
        '              2     2       2      2

        '               2    2
        '             1  1           1      1
        '               2    2
        '             1  1              2      2
        '                            1      1
        '                               2      2

    ELSEIF c_type = unfiltered THEN
        GOTO fusilli
    END IF
NEXT
IF qual THEN ScanControls& = i

END SUB


SUB SweepControls (from AS intpair, too AS intpair)
' given a (?)point or an area -
' enable detection of more than two hoverables


'can be part of the effort to create an easy way to establish tab order
'NI: optionally change names ;* remember to scan for children controls and duplicate change

STATIC def__ar AS _BYTE, collection() AS LONG
IF NOT def__ar THEN DIM collection(0) AS LONG: def__ar = -1
REDIM _PRESERVE collection(UBOUND(collection) + 1) AS LONG

'?
IF fout THEN fi& = 0 ' does this prevent oor errors on uix_sweeplist ?
'?

FOR i% = 1 TO UBOUND(control)
    ' 'SetCaption (Brush10), STR$(UBOUND(control))

    ' 'SetCaption (Brush11), STR$(ScanControls(from, too, __uix_unfiltered, 22))


    'scancontrols& (from , too, __uix_unfiltered)
    mout = (fout + 1) MOD UBOUND(control): IF mout = 0 THEN mout = 1 ' avoiding detecting the 0th control
    fout = ScanControls(from, too, __uix_unfiltered, mout)
    'fail' (fout -1)mod UBOUND(control) + 2 )
    '' not                      uix_sweeplist(UBOUND(uix_sweeplist)) + 1 _
    '                      )


    'big diag
    ''SELECT CASE i%
    ''    CASE 1
    ''        SetCaption Brush1, STR$(fout)
    ''    CASE 2
    ''        SetCaption Brush2, STR$(fout)
    ''    CASE 3
    ''        SetCaption Brush3, STR$(fout)
    ''    CASE 4
    ''        SetCaption Brush4, STR$(fout)
    ''END SELECT
    ''SetCaption Brush6, STR$(from.a)

    ''SetCaption Brush5, STR$(from.z)


    IF fout THEN
        fi& = fi& + 1
        IF fi& > 1 THEN ' ubouns(uix_sweeplist) > 0

            '?a sub range error found in the following line '
            IF fout <> uix_sweeplist(1) THEN REDIM _PRESERVE uix_sweeplist(i%) AS LONG: uix_sweeplist(i%) = fout ELSE EXIT FOR
        ELSE
            REDIM _PRESERVE uix_sweeplist(i%) AS LONG: uix_sweeplist(i%) = fout
        END IF
    END IF
NEXT i%


END SUB

FUNCTION Feel&: Feel& = __UI_HoveringID
END FUNCTION

FUNCTION Zupreme& (This AS LONG)
'a typical call would look like this: Button32=Zupreme(Button32)
DIM i AS LONG, ub AS LONG, dummy AS __UI_ControlTYPE, str_dummy(1 TO 8) AS STRING

FOR i = 1 TO UBOUND(Control)
    'this works badly, do not know why...
    ' IF Control(i).ID <> 0 THEN ub = i: IF This > ub THEN This = 0: EXIT FUNCTION ELSE EXIT FOR
    '   . . .but this
    IF Control(i).ID <> 0 THEN ub = i: IF This > ub THEN Zupreme& = This: EXIT FUNCTION ELSE EXIT FOR
NEXT i
Zupreme& = ub
IF ub - This > 200 THEN n$ = ErrorCage("awkwardly large z-upreming") 'optionally so
dummy = Control(This)
str_dummy(1) = Caption(This): str_dummy(2) = ToolTip(This): str_dummy(3) = Text(This): str_dummy(4) = Mask(This): str_dummy(5) = __UI_TempTexts(This): str_dummy(6) = __UI_TempCaptions(This): str_dummy(7) = __UI_TempTips(This): str_dummy(8) = __UI_TempMask(This)
FOR i = This TO ub - 1
    Control(i) = Control(i + 1): Caption(i) = Caption(i + 1): ToolTip(i) = ToolTip(i + 1): Text(i) = Text(i + 1): Mask(i) = Mask(i + 1)
    Control(i).ID = i: __UI_TempTexts(i) = __UI_TempTexts(i + 1): __UI_TempCaptions(i) = __UI_TempCaptions(i + 1): __UI_TempTips(i) = __UI_TempTips(i + 1): __UI_TempMask(i) = __UI_TempMask(i + 1)
NEXT i
Control(ub) = dummy: Control(ub).ID = ub
Caption(ub) = str_dummy(1): ToolTip(ub) = str_dummy(2): Text(ub) = str_dummy(3): Mask(ub) = str_dummy(4): __UI_TempTexts(ub) = str_dummy(5): __UI_TempCaptions(ub) = str_dummy(6): __UI_TempTips(ub) = str_dummy(7): __UI_TempMask(ub) = str_dummy(8)

FOR i = 1 TO UBOUND(control)
    pi = Control(i).ParentID
    IF pi = This THEN Control(i).ParentID = ub
    IF pi > This THEN IF pi <= ub THEN Control(i).ParentID = pi - 1
NEXT i&
' Zupreme& = 'see above
END SUB


FUNCTION FindKid& (__of&)
'returns the ID of earliest VALID child of a [frame] control
FOR i& = __of& TO UBOUND(control)
    IF Control(i&).ParentID = __of& THEN FindKid& = i&: EXIT FOR
NEXT i&
END FUNCTION

SUB ReadFile (spec$)
spec$ = "default"

IF _FILEEXISTS(spec$ + ".bil") THEN
ELSE
    PRINT "file name "; spec$; " not found in current path"
    EXIT SUB
END IF

REDIM dummy(0) AS room, dummys(0) AS roomsup: struc.size = LEN(dummy(0)): sup.size = LEN(dummys(0)): ERASE dummy, dummys

h1 = FREEFILE
OPEN spec$ + ".bil" FOR INPUT AS h1

mapdat$ = INPUT$(4, h1)


'discover sizes
IF LOF(h1) >= ver_h_size + 4 THEN mapdat$ = INPUT$(ver_h_size, h1)
mapver$ = RIGHT$(mapdat$, 8)
IF MID$(mapver$, 3, 1) = "." AND MID$(mapver$, 6, 1) = "." THEN
ELSE
    PRINT "format not recognized for file name "; spec$
    EXIT SUB
END IF

SHARED __incr_pos AS LONG
__incr_pos = ver_h_size 'len of what was already read


header_size = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :header_size=cvl(mapdat$)
Readsiz_rm = Readalong(h1) ' mapdat$ = INPUT$(4, h1) :Readsiz_rm=cvl(mapdat$)
Readsiz_pt = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_pt=cvl(mapdat$)
Readsiz_ot = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_ot=cvl(mapdat$)
Readsiz_cv = Readalong(h1) 'mapdat$ = INPUT$(4, h1) :Readsiz_cv=cvl(mapdat$)
nul$ = Readabunch(header_size - __incr_pos, h1)

loopquan = Readsiz_rm \ struc.size 'ln - header.size
REDIM _PRESERVE rooms(0 TO loopquan) AS room
FOR i = 0 TO loopquan
    mapdat$ = Readabunch(struc.size, h1)
    IF i > 0 THEN
        RT__room rooms(i), mapdat$
    ELSE
        DIM holder AS room
        RT__room holder, mapdat$
        '! set the rooms x and y vars = .now and .isof
    END IF
NEXT i

''   REDIM _PRESERVE paths( loopquan to  loopquan ) AS room
loopquan = Readsiz_pt \ struc.size
''   REDIM _PRESERVE paths(lbound(paths) to lbound(paths)+  loopquan ) AS room
REDIM _PRESERVE paths(0 TO loopquan) AS room
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(struc.size, h1)
    RT__room paths(i), mapdat$
NEXT i

loopquan = Readsiz_ot \ sup.size

REDIM _PRESERVE visualchar(0 TO loopquan) AS roomsup
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(sup.size, h1)
    RT__room paths(i), mapdat$
NEXT i

'custom values section

mapdat$ = Readabunch(Readsiz_cv, h1)

'!process the c.d.


END SUB



SUB calcPathGrid (x, y)

''using screen height as size limiter - this used three places
'basex = 8: basey = 8
'boxsize = (80 - basey) \ y
'FOR a = 1 TO x
'    FOR b = 1 TO y
'        ressup(a + (b - 1) * x).offset.a = (basex + boxsize * (a - 1))
'        ressup(a + (b - 1) * x).offset.z = (basey + boxsize * (b - 1))
'NEXT b, a
END SUB

SUB addpath (ends AS intpair, pathid)
SHARED brush
'havent switched rooms() access to lib_rooms_main() access
pathid = UBOUND(path) + 1
IF pathid = 1 THEN pathid = UBOUND(res) + 1: REDIM path(pathid - 1 TO pathid) AS room
REDIM _PRESERVE path(pathid) AS room

'make sure there's a free slot in dest
FOR i = 1 TO 1
    IF rooms(ends.z).exit1 = 0 THEN

    ELSEIF rooms(ends.z).exit2 = 0 THEN

    ELSEIF rooms(ends.z).exit3 = 0 THEN

    ELSEIF rooms(ends.z).exit4 = 0 THEN

    ELSEIF rooms(ends.z).exit5 = 0 THEN

    ELSEIF rooms(ends.z).exit6 = 0 THEN

    ELSEIF rooms(ends.z).exit7 = 0 THEN

    ELSEIF rooms(ends.z).exit8 = 0 THEN

    END IF
    EXIT SUB
NEXT
'set for org
FOR i = 1 TO 1
    IF rooms(ends.a).exit1 = 0 THEN
        rooms(ends.a).exit1 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit2 = 0 THEN
        rooms(ends.a).exit2 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit3 = 0 THEN
        rooms(ends.a).exit3 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit4 = 0 THEN
        rooms(ends.a).exit4 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit5 = 0 THEN
        rooms(ends.a).exit5 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit6 = 0 THEN
        rooms(ends.a).exit6 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit7 = 0 THEN
        rooms(ends.a).exit7 = pathid: EXIT FOR
    ELSEIF rooms(ends.a).exit8 = 0 THEN
        rooms(ends.a).exit8 = pathid: EXIT FOR
    END IF
    EXIT SUB
NEXT
'set for dest
FOR i = 1 TO 1
    IF rooms(ends.z).exit1 = 0 THEN
        rooms(ends.z).exit1 = pathid
    ELSEIF rooms(ends.z).exit2 = 0 THEN
        rooms(ends.z).exit2 = pathid
    ELSEIF rooms(ends.z).exit3 = 0 THEN
        rooms(ends.z).exit3 = pathid
    ELSEIF rooms(ends.z).exit4 = 0 THEN
        rooms(ends.z).exit4 = pathid
    ELSEIF rooms(ends.z).exit5 = 0 THEN
        rooms(ends.z).exit5 = pathid
    ELSEIF rooms(ends.z).exit6 = 0 THEN
        rooms(ends.z).exit6 = pathid
    ELSEIF rooms(ends.z).exit7 = 0 THEN
        rooms(ends.z).exit7 = pathid
    ELSEIF rooms(ends.z).exit8 = 0 THEN
        rooms(ends.z).exit8 = pathid
    END IF
    EXIT SUB
NEXT
'build path resource
path(pathid).exit1 = ends.a
path(pathid).exit2 = ends.z
path(pathid).rmdesc = brush
END SUB



FUNCTION Resolve (idx)
IF rooms(idx).isof = 0 THEN Resolve = idx ELSE Resolve = rooms(idx).isof
END FUNCTION


SUB LoadResources

'primitive

IF _FILEEXISTS("res_mb\blnk.room.jpg ") THEN
    FoundRes$(0) = "res_mb\blnk.room.jpg"
    IF happres(0) >= -1 THEN happres(0) = _LOADIMAGE(FoundRes$(0), 32)
END IF
IF _FILEEXISTS("res_mb\std.room.jpg") THEN
    FoundRes$(res_room) = "res_mb\std.room.jpg"
    IF happres(res_room) >= -1 THEN happres(res_room) = _LOADIMAGE(FoundRes$(res_room), 32)
END IF
load_fail = 2
IF _FILEEXISTS("res_mb\room.shrine.jpg") THEN
    FoundRes$(res_shrine) = "res_mb\room.shrine.jpg"
    IF happres(res_shrine) >= -1 THEN happres(res_shrine) = _LOADIMAGE(FoundRes$(res_shrine), 32): load_fail = False
    IF load_fail THEN n$ = ErrorCage("load_fail at " + STR$(load_fail))
END IF

END SUB

SUB PlaceToScale (bstatic AS _BYTE)
'destroying + remaking original controls may cause a problem w this procedure
SHARED __orgwidth_Area, __orgheight_Area: IF __orgwidth_Area = 0 THEN __orgwidth_Area = Control(Area).Width
IF __orgheight_Area = 0 THEN __orgheight_Area = Control(Area).Height
'all left properties
STATIC expand_LB, Expand_BT,  __Frame2,__Frame3, _
__Expand_Bar
IF bstatic = True THEN
    recali:
    expand_LB = Control(MazeBuilder).Left - Control(expandLB).Left
    Expand_BT = Control(MazeBuilder).Left - Control(ExpandBT).Left

    '    __Frame1 = Control(MazeBuilder).Left - Control(Frame1).Left
    __Frame2 = Control(MazeBuilder).Left - Control(Frame2).Left
    __Frame3 = Control(MazeBuilder).Left - Control(Frame3).Left
    __Expand_Bar = Control(MazeBuilder).Left - Control(ExpandBar).Left


ELSE

    Control(Area).Width = __orgwidth_Area + (_RESIZEWIDTH - app.formwidth)
    ''  app.formwidth = _WIDTH(0)
    Control(Area).Height = __orgheight_Area + (_RESIZEHEIGHT - app.formheight)
    cml = Control(MazeBuilder).Left
    Control(expandLB).Left = cml - expand_LB
    Control(ExpandBT).Left = cml - Expand_BT
    Control(Frame2).Left = cml - __Frame2
    Control(Frame3).Left = cml - __Frame3
    Control(ExpandBar).Left = cml - __Expand_Bar
    '.
    '.
    '.
    __UI_ForceRedraw = True
    GOTO recali
END IF
END SUB

SUB adjustzoom (factor)

'set up the scale variables
levels_defined = 8

SHARED zoom_mults() AS SINGLE
zoom_mults(1) = 2.5
zoom_mults(2) = 1
zoom_mults(3) = 1 / 2
zoom_mults(4) = 1.3 / 3
zoom_mults(5) = 1 / 3
zoom_mults(6) = 1.4 / 4
zoom_mults(7) = 1 / 4
zoom_mults(8) = 1.5 / 5
' zoom.width= zoom_mults(zoom.level)
'zoom.height= zoom_mults(zoom.level)
''zoom.width = app.roomwidth * zoom.level: zoom.height = app.roomheight * zoom.level
'zoom.width = zoom_mults(zoom.level): zoom.height = zoom_mults(zoom.level)

' zoom.level
END SUB

FUNCTION adjust_scroll%% (d, size AS LONG)

'! FOUR _newcontrol's to adjust (add zoom scaling to size; position)

diag_call_reg_2 "ad[" '"adjs["

'scroll is defined to be a directed value between 1-10 divided into
' the ratio at the current zoom level of the total size of areadim.a,z (mixed with zoom.width;height) to the
' total h or w of the frame, Area,

'
' thus given a total size of areadim.a * zoom.width = 110 and 100 for Area width
'  scrollmag = (110 - 100) / (10 - 1)

'  scroll.top, scroll.left

scrmin = 1
scrmax = 10
scrolloutmult_thresh = .5

IF d = 1 THEN scrollmag = (areadim.a * 80 * 1 - Control(Area).Width) / (scrmax - scrmin)
IF d = 2 THEN scrollmag = (areadim.z * 53 * 1 - Control(Area).Height) / (scrmax - scrmin)
'IF d = 1 THEN scrollmag = (areadim.a ** zoom.width - Control(Area).Width) / (scrmax - scrmin)
'IF d = 2 THEN scrollmag = (areadim.z ** zoom.height - Control(Area).Height) / (scrmax - scrmin)

SetCaption Brush5, LEFT$(STR$(scrollmag), 6)

SetCaption Brush6, "m" + LEFT$(STR$(scrollmag), 6)

'   SetCaption Brush6, STR$(from.a)


IF scrollmag <= 1 THEN EXIT SUB '...no scrolling when all existing tiles can be fit

DIM scrvec AS intpair
IF d = 1 AND scroll.left + size >= scrmin AND scroll.left + size <= scrmax THEN
    scrvec.a = size * scrollmag
ELSEIF d = 2 AND scroll.top + size >= scrmin AND scroll.top + size <= scrmax THEN
    scrvec.z = size * scrollmag
END IF


IF greater(scrvec.a, scrvec.z) <> 0 THEN ' if we are go to scroll
    'method std
    'horz mv
    si = SGN(scrvec.a) / 2: si2 = SGN(scrvec.z) / 2
    diag_call_reg_2 "adjs."
    IF si THEN
        'see if zoom amt exceeds one tile
        crunchct = (scrvec.a - (zoom.width + Control(controlrange.min).Left)) \ greater(1, zoom.width) '-->ELSE crunchct = scrvec.z ... \ greater(1, zoom.height)
        'results in
        '    FOR ix = 1 * (.5 - si) + (UBOUND(areaarr, 1) - crunchct + 1) * (si + .5) TO crunchct * (.5 - si) + UBOUND(areaarr, 1) * (si + .5)
        '        '        FOR iy = 1 * ABS(si2 - .5) + (UBOUND(areaarr, 2) - crunchct + 1) * ABS(si2 + .5) TO crunchct * ABS(si2 - .5) + UBOUND(areaarr, 2) * ABS(si2 + .5)
        'will not work ^, absent si quantities negate, not zero out
        ' up -.5
        'having destroyed a row(s) or a column(s),  id the first killed frame widget
        crunched = 0
        REDIM ren_id(0) AS intpair
        FOR ix = 1 TO UBOUND(areaarr, 1)
            FOR iy = 1 TO UBOUND(areaarr, 2)
                IF ix <= crunchct * ABS(si - .5) THEN
                    GOTO linguine
                ELSEIF (si + .5) * ix > UBOUND(areaarr, 1) - crunchct THEN
                    linguine: 'label
                    FlameDestroy AreaArr(ix, iy)
                    IF crunched = 0 THEN crunched = ix
                    ps = UBOUND(ren_id) + 1
                    REDIM _PRESERVE ren_id(ps) AS intpair
                    ren_id(ps).a = ix: ren_id(ps).z = iy
                ELSE
                   Control(AreaArr(ix, iy)).Left=_
                      Control(AreaArr(ix, iy)).Left + scrvec.a
                END IF

        NEXT: NEXT
        '   then produce the number of widgets that got destroyed...
        IF crunched THEN
            ren_start = 0
            box = Control(Area).Left: boy = Control(Area).Top
            ''FOR ix = 1 TO (si + .5) * crunchct + UBOUND(areaarr, 1) * ABS(si - .5)
            i2 = (.5 - si) * (UBOUND(areaarr, 1) - crunchct)
            FOR ix = 1 TO crunchct
                FOR iy = 1 TO UBOUND(areaarr, 2)
                    AreaArr(ix + i2, iy) = __UI_NewControl(__UI_Type_Frame, prefix1$2, app.roomwidth, app.roomheight, box + (ix + i2 - 1) * zoom.width, boy + (iy - 1) * zoom.height, 0)
                    IF ren_start = 0 THEN ren_start = AreaArr(ix + i2, iy)
                    Control(AreaArr(ix + i2, iy)).HasBorder = False
                    'diag
                    SetCaption (LabelTT), STR$(VAL(Caption(LabelTT)) + 1)
            NEXT: NEXT
        END IF

    ELSE
        'or do for alternative direction
        crunchct = scrvec.z - (zoom.height + Control(controlrange.min).Top) \ greater(1, zoom.height)

        crunched = 0
        REDIM ren_id(0) AS intpair
        FOR ix = 1 TO UBOUND(areaarr, 1)
            FOR iy = 1 TO UBOUND(areaarr, 2)
                IF iy <= crunchct * ABS(si2 - .5) THEN
                    GOTO minestrone
                ELSEIF (si2 + .5) * iy > UBOUND(areaarr, 2) - crunchct THEN
                    minestrone: 'label
                    FlameDestroy AreaArr(ix, iy)
                    IF crunched = 0 THEN crunched = iy
                    ps = UBOUND(ren_id) + 1
                    REDIM _PRESERVE ren_id(ps) AS intpair
                    ren_id(ps).a = ix: ren_id(ps).z = iy
                ELSE
                   Control(AreaArr(ix, iy)).Top=_
                      Control(AreaArr(ix, iy)).Top + scrvec.z
                END IF

        NEXT: NEXT
        '   then produce the number of widgets that got destroyed...
        IF crunched THEN
            diag_call_reg_2 ".."
            ren_start = 0
            box = Control(Area).Left: boy = Control(Area).Top
            i2 = (.5 - si2) * (UBOUND(areaarr, 2) - crunchct)

            FOR ix = 1 TO UBOUND(areaarr, 1)
                FOR iy = 1 TO crunchct
                    AreaArr(ix, iy + i2) = __UI_NewControl(__UI_Type_Frame, prefix1$2, app.roomwidth, app.roomheight, box + (ix - 1) * zoom.width, boy + (iy + i2 - 1) * zoom.height, 0)
                    Control(AreaArr(ix, iy + i2)).HasBorder = False
                    '...
                    IF ren_start = 0 THEN ren_start = AreaArr(ix, iy + i2)

                    'diag
                    SetCaption (LabelTT), STR$(VAL(Caption(LabelTT)) + 1)
            NEXT: NEXT
        END IF

    END IF
    SHARED prefix1$2, prefix2$2
    IF crunched THEN
        '... and alter their registry to be what content of AreaArr 's are not existing
        FOR i = ren_start TO UBOUND(control) '[not doing] -1 STEP 2 'select all new creation frame
            pi = AreaArr(ren_id(ps).a, ren_id(ps).z)
            SWAP Control(i), Control(pi)
            Control(pi).ID = pi
            '?
            '            nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2, app.roomwidth, app.roomheight, 1, 1, pi)

            nameless = __UI_NewControl(__UI_Type_PictureBox, prefix2$2, app.roomwidth, app.roomheight, 1, 1, pi)

            'but don't bother:control(pi).name = control(pi).name+ltrim$ str$:control(pi).name = control(nameless).name+ltrim$ str$
            'u' set em clear

        NEXT i

    END IF


    '   if movement was leftward or upward (neg): subtract a quantity from each still existing AreaArr 's ID
    '   if movement was rightward or downward (neg):add a quantity to each still existing AreaArr 's ID

    '... re-filling frame widgets with PB widgets as we go

END IF
'  controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)
' adjust VirtualOffset .a.z
diag_call_reg_2 "adjs]"
Cursor = Zupreme(Cursor)
adjust_scroll%% = True

END SUB


SUB RT__room (t AS room, d$)
DIM i AS _UNSIGNED INTEGER, size AS _UNSIGNED INTEGER, ftesize AS _UNSIGNED INTEGER
DIM m AS _MEM, pt AS _OFFSET, deco AS _BYTE
size = LEN(t): m = _MEM(t)
FOR i = 1 TO size
    deco = _CV(_BYTE, MID$(d$, i, 1))
    _MEMPUT m, m.OFFSET + i - 1, deco
NEXT i
END SUB

SUB Trans (a AS LONG, o AS intpair)
'as, usually, we'd need the .a or .z equivalent

o.a = a MOD roomboxsize.a
o.z = 1 + (a - 1) \ roomboxsize.a
'reverse calc is .a+roomboxsize.a * (.z-1)
END SUB
FUNCTION LocTrans& (id)
LocTrans = roomboxsize.a * (VirtualOffset.z - 1) + VirtualOffset.a - 1 + id - controlrange.min
END SUB


FUNCTION NextTime! (timedelta AS SINGLE)
nt! = (TIMER(.001) + timedelta) - (nt! \ 86400) * 86400 'just prevent out of bounds values when comparing TIMER output
NextTime! = nt!

END FUNCTION


SUB ADvalidate
'make sure controls don't over-flow the reg

areadim.a = lesser(areadim.a + 1, Control(Area).Width / 80 / 1)
''SetCaption Brush8, STR$(lesser(areadim.z, Control(Area).Height / 53 / 1))
areadim.z = lesser(areadim.z + 1, Control(Area).Height / 53 / 1)
areadim.a = areadim.a - 1
areadim.z = areadim.z - 1

END SUB


FUNCTION lesser## (c1##, c2##): IF c1## < c2## THEN lesser## = c1## ELSE lesser## = c2##
END FUNCTION

FUNCTION greater## (c1##, c2##): IF c1## > c2## THEN greater## = c1## ELSE greater## = c2##

END FUNCTION


SUB PaintYou (targ AS LONG, tile_id AS INTEGER)
'
SELECT CASE tile_id
    CASE 0: LoadImage Control(targ), "res_mb/blnk.room.jpg"
    CASE 1: LoadImage Control(targ), "res_mb/std.room.jpg"
    CASE 2: LoadImage Control(targ), "res_mb/straight.jpg"
END SELECT
END SUB

SUB MapResource (res_id AS LONG, ctrl_id AS LONG)
'transpation fn
IF res_id <= UBOUND(happres) THEN
    IF happres(res_id) < -1 THEN
        '' _FREEIMAGE Control(ctrl_id).HelperCanvas 'ifc
        Control(ctrl_id).HelperCanvas = _COPYIMAGE(happres(res_id), 33)
        Control(ctrl_id).PreviousValue = 0
END IF: END IF
END SUB


SUB WipeTile (This AS LONG)
kd& = _DEST: _DEST Control(This).HelperCanvas
PAINT (0, 0), _RGB32(0, 0, 0)
_DEST kd&


END FUNCTION

FUNCTION Readabunch$ (size AS LONG, hfile AS LONG)
'of bytes from a file
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + size
IF hfile THEN Readabunch$ = INPUT$(size, hfile)
END FUNCTION

FUNCTION Readalong& (hfile AS LONG)
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + LEN(a&)
IF hfile THEN Readalong& = CVL(INPUT$(4, hfile))
END FUNCTION



SUB CarryRoom (which AS LONG, targ AS LONG)
'target:library copy


' execute a swap, but later beh change to replace
SWAP Control(FindKid(which)), Control(FindKid(targ))
'making unnec:
'PaintYou FindKid(which), rooms(LocTrans  (which)).rmdesc
'PaintYou FindKid(targ), rooms(LocTrans  (targ)).rmdesc


'  local_a =  roomboxsize.a * (VirtualOffset.z - 1) + VirtualOffset.a - 1 + id - controlrange.min

SWAP rooms(LocTrans(which)), rooms(LocTrans(targ))



'swap which, lib_rooms_main((-1 + iy) - (roomboxsize.a +2)).rmdesc
'              lib_rooms_main
'! paths !!!


END SUB

SUB nonworking
DIM dummy AS __UI_ControlTYPE
dummy.ID = __UI_NewControl(__UI_Type_Frame, "Frame1", Control(Frame1).Width, Control(Frame1).Height, Control(Frame1).Left, Control(Frame1).Top, 0)
SWAP Control(Frame1), dummy
SetCaption Frame1, ""
SWAP Control(dummy.ID).ID, Control(Frame1).ID
''Control(Frame1).ID = Frame1
__UI_DestroyControl dummy
' would this work in place of the ccursor destroy
END SUB

SUB diagnosticalinit

adjustzoom 0
app.formwidth = 1024
app.formheight = 768
app.roomwidth = 80: app.roomheight = 53
zoom.level = 2

END SUB

SUB diag_call_reg (msg$): END SUB
SUB diag_call_reg_2 (msg$)

'AddItem Scrolltrial2, msg$
Text(TTText) = Text(TTText) + msg$

END SUB


FUNCTION zoom.width ()
SHARED zoom_mults() AS SINGLE

STATIC extlevels_defined, levels_defined, zoom_mults() AS SINGLE
IF NOT extlevels_defined THEN
    levels_defined = 8
    ' DIM zoom_mults(levels_defined) AS SINGLE
    zoom_mults(1) = 2.5
    zoom_mults(2) = 1
    zoom_mults(3) = 1 / 2
    zoom_mults(4) = 1.3 / 3
    zoom_mults(5) = 1 / 3
    zoom_mults(6) = 1.4 / 4
    zoom_mults(7) = 1 / 4
    zoom_mults(8) = 1.5 / 5
extlevels_defined = True: END IF

zoom.width = zoom_mults(zoom.level)
SHARED zoom.crit
IF zoom.crit THEN zoom.width = 1

END FUNCTION
'zoom.width = app.roomwidth * zoom.level: END FUNCTION

FUNCTION zoom.height ()
STATIC extlevels_defined, levels_defined, zoom_mults() AS SINGLE
SHARED zoom_mults() AS SINGLE
IF NOT extlevels_defined THEN
    levels_defined = 8
    '  DIM zoom_mults(levels_defined) AS SINGLE
    zoom_mults(1) = 2.5
    zoom_mults(2) = 1
    zoom_mults(3) = 1 / 2
    zoom_mults(4) = 1.3 / 3
    zoom_mults(5) = 1 / 3
    zoom_mults(6) = 1.4 / 4
    zoom_mults(7) = 1 / 4
    zoom_mults(8) = 1.5 / 5
extlevels_defined = True: END IF
''adjustzoom (factor)
zoom.height = zoom_mults(zoom.level)
SHARED zoom.crit
IF zoom.crit THEN zoom.height = 1
END FUNCTION

FUNCTION RMBstate%%: RMBstate%% = __UI_MouseButton2
END FUNCTION

FUNCTION ErrorCage$ (msg$)
STATIC Errorz AS STRING
ErrorCage = Errorz
Errorz = Errorz + msg$

END SUB

SUB spotchange (id, res_id)
PaintYou FindKid(id), rooms(res_id).rmdesc

'draw paths next


END SUB

SUB prot_setZoomValue (zscl AS SINGLE)
diag_call_reg "pzv" + LTRIM$(STR$(zscl))


'first sync delta canvas to res() ; repeat for paths ; and again, for

'get center offset from area's corner offset, mutiply by the factor and derive corner offset from there again

'check corners with offset

'derive new scroll position - ex, if a factor is 2/3 then 3/2 are now to be shown, and left offscreen part, mulxed by factor gains (1-3/2) /2 of what's shown. resulting sum if positive divved by original left offscreen part makes new scroll pos

';



END SUB



SUB InVisiblate

'Control(ZoomBar).Hidden = True

Control(ExpandBT).Hidden = True
Control(ZoomBar).Hidden = True
Control(Frame2).Hidden = True
Control(Frame3).Hidden = True

END SUB
