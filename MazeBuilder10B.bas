': This program was generated by
': InForm - GUI system for QB64 - Beta version 3
': Fellippe Heitor, 2016 - fellippe@qb64.org - @fellippeheitor
'-----------------------------------------------------------

': Controls' IDs: ------------------------------------------------------------------
DIM SHARED MazeBuilder AS LONG
DIM SHARED Button1 AS LONG
DIM SHARED Button2 AS LONG
DIM SHARED Button3 AS LONG
DIM SHARED Button4 AS LONG
DIM SHARED Button8 AS LONG
DIM SHARED Button5 AS LONG
DIM SHARED Button7 AS LONG
DIM SHARED Button6 AS LONG
DIM SHARED Button9 AS LONG
DIM SHARED Button10 AS LONG
DIM SHARED Button11 AS LONG
DIM SHARED Button12 AS LONG
DIM SHARED PictureBox1 AS LONG
DIM SHARED Button13 AS LONG
DIM SHARED Button14 AS LONG
DIM SHARED TextTT AS LONG
DIM SHARED Button15 AS LONG
DIM SHARED Button16 AS LONG
DIM SHARED Button17 AS LONG
DIM SHARED ZoomBar AS LONG
DIM SHARED ApplyBT AS LONG
DIM SHARED Scrolltrial AS LONG

DIM SHARED Frame AS LONG
DIM SHARED Frame3 AS LONG
DIM SHARED expandLB AS LONG
DIM SHARED EnterBT AS LONG
DIM SHARED LoadBT AS LONG
DIM SHARED SaveBT AS LONG

DIM SHARED Frame1 AS LONG
DIM SHARED ExpandBT AS LONG
DIM SHARED TopRB AS LONG

DIM SHARED BottomRB AS LONG
DIM SHARED RightRB AS LONG
DIM SHARED LeftRB AS LONG
DIM SHARED LabelTT AS LONG
DIM SHARED TrackBar3 AS LONG
DIM SHARED Area AS LONG
DIM SHARED Frame5 AS LONG 'cursor


' MazeBuilder Base Types
'  * * * * * please copy this into your target application
TYPE intpair
    a AS INTEGER
    z AS INTEGER
END TYPE

TYPE room
' firsttypeelement AS _UNSIGNED _BYTE
    now AS INTEGER ' as unique index
    rmdesc AS _BYTE
    isof AS INTEGER
    rmelab AS STRING * 8
    ' ^ possible ideas:
    ' * feature of merged path * idx of a room descr * unique treasure * class name
    exit1 AS INTEGER
    exit2 AS INTEGER
    exit3 AS INTEGER
    exit4 AS INTEGER
    exit5 AS INTEGER
    exit6 AS INTEGER
    exit7 AS INTEGER
    exit8 AS INTEGER
END TYPE
TYPE roomsup
    offset AS intpair 'internal calc
    customoffset AS intpair
    'clock face positioning of the tunnel graphics
    exit1 AS _BYTE
    exit2 AS _BYTE
    exit3 AS _BYTE
    exit4 AS _BYTE
    exit5 AS _BYTE
    exit6 AS _BYTE
    exit7 AS _BYTE
    exit8 AS _BYTE
END TYPE
TYPE MazebuildProps
    formwidth AS INTEGER
    formheight AS INTEGER
    roomwidth AS INTEGER
    roomheight AS INTEGER
    brush AS INTEGER

END TYPE
TYPE DragControl
    dragstart AS SINGLE
    dragon AS _BYTE
END TYPE

CONST res_room = 1
CONST drag_thresh = .15
DIM SHARED app AS MazebuildProps
DIM SHARED AreaCursor AS DragControl
DIM SHARED reshandles(16) AS LONG
DIM SHARED scroll.top, scroll.left, zoom.value ', zoom.width, zoom.height
diagnosticalinit '############

redim SHARED rooms(0) AS room, paths(0) AS room, _
        visualchar(0  ) AS roomsup
REDIM SHARED AreaArr(0, 0) AS LONG, areadim AS intpair
DIM SHARED controlrange.max AS LONG, controlrange.min AS LONG

LoadResources

': External modules: ---------------------------------------------------------------
'$INCLUDE:'InForm\InForm.ui'
'$INCLUDE:'InForm\xp.uitheme'
'$INCLUDE:'MazeBuilder10B.frm'

': Event procedures: ---------------------------------------------------------------
SUB __UI_BeforeInit

END SUB

SUB __UI_OnLoad

PlaceToScale True

'Set up zoomer and scroller(s)
Trackbar1.Interval = 1
Trackbar1.Value = 2
Trackbar1.Min = 1: Trackbar1.Max = 4 ' temporary initial val
FOR i = 1 TO 200
    AddItem Scrolltrial, " "
NEXT i


Control(Frame).Top = Control(expandLB).Top + Control(expandLB).Height + 15
Control(Frame).Left = Control(expandLB).Left - 34
Control(Frame3).Top = Control(expandLB).Top + Control(Frame).Height + Control(expandLB).Height + 12
Control(Frame3).Left = Control(expandLB).Left - 34
Control(Frame).HasBorder = False
Control(Frame3).HasBorder = False

Control(RightRB).Value = True
Control(BottomRB).Value = True

' SAMPLE- Set up blank area
areadim.a = 6: areadim.z = 6


'cleanup
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        px = AreaArr(ix, iy)
        IF px THEN __UI_DestroyControl Control(px) ' mean for the control to have contiguous indices
NEXT: NEXT
ERASE AreaArr: REDIM AreaArr(areadim.a, areadim.z) AS LONG

boy = Control(PictureBox1).Left: boy = Control(PictureBox1).Top
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        ic& = ic& + 1

        AreaArr(ix, iy) = __UI_NewControl(__UI_Type_Frame, "^A" + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, box + (ix - 1) * zoom.width, boy + (iy - 1) * zoom.height, 0)


NEXT: NEXT: ic& = 0
FOR ix = 1 TO UBOUND(areaarr, 1)
    FOR iy = 1 TO UBOUND(areaarr, 2)
        ic& = ic& + 1

        nameless = __UI_NewControl(__UI_Type_PictureBox, "AA" + LTRIM$(STR$(ic&)), app.roomwidth, app.roomheight, 1, 1, AreaArr(ix, iy))

        LoadImage Control(nameless), "res_mb/blnk.room.jpg" '/reshandles(res_room )
NEXT: NEXT
controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)


END SUB

SUB __UI_BeforeUpdateDisplay


Control(Frame5).Hidden = False
'--set

IF AreaCursor.dragstart > 0 AND AreaCursor.dragstart < TIMER(.001) THEN AreaCursor.dragon = True

IF _RESIZE THEN
    PlaceToScale False
END IF

END SUB

SUB __UI_BeforeUnload

END SUB

SUB __UI_Click (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12
        'move cursor
        '  flag fCP(id)

        Control(Frame5).HasBorder = True
        Control(Frame5).BorderColor = _RGBA32(255, 180, 0, 255)
        '?'
        Control(Frame5).Top = Control(id).Top - 8
        Control(Frame5).Left = Control(id).Left - 8
        __UI_ForceRedraw = True


    CASE Area, PictureBox1

    CASE ApplyBT
        Control(Frame1).Hidden = True
        Control(ExpandBT).Hidden = False: Control(ExpandBT).Disabled = False
        Control(ZoomBar).Disabled = False
        __UI_ForceRedraw = True
    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT
        Control(Frame1).Hidden = False

        Control(ExpandBT).Hidden = True: Control(ExpandBT).Disabled = True
        Control(ZoomBar).Disabled = True
        __UI_ForceRedraw = True

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max
        'BUT, will not work, save when a contiguous range is available
        '   v  & &
END SELECT
IF LEFT$(Control(id).Name, 2) = "AA" THEN
    ' & &

    '  .rmdesc = 1 '    (app.brush)

END IF
END SUB

SUB __UI_MouseEnter (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_MouseLeave (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_FocusIn (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_FocusOut (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max
END SELECT
END SUB

SUB __UI_MouseDown (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max
        AreaCursor.dragstart = NextTime(drag_thresh)


END SELECT
END SUB

SUB __UI_MouseUp (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area, PictureBox1
        '    if  timer(.001)>AreaCursor.dragstart
        IF AreaCursor.dragon THEN

            'execute drag
        END IF

    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max
END SELECT
AreaCursor.dragstart = -1
AreaCursor.dragon = False
END SUB

SUB __UI_KeyPress (id AS LONG)
SELECT CASE id
    CASE MazeBuilder

    CASE Button1, Button2, Button3, Button4, Button5, Button6,_
        Button7, Button8, Button9, Button10, Button11, Button12

    CASE Area

    CASE PictureBox1


    CASE ApplyBT

    CASE Button13

    CASE Button14

    CASE TextTT

    CASE Button15

    CASE Button16

    CASE Button17

    CASE ZoomBar

    CASE Frame1

    CASE Frame

    CASE Frame3

    CASE Frame5

    CASE ExpandBT

    CASE expandLB

    CASE TopRB

    CASE BottomRB

    CASE RightRB

    CASE LeftRB

    CASE EnterBT

    CASE LoadBT

    CASE SaveBT

    CASE LabelTT

    CASE TrackBar3

    CASE controlrange.min TO controlrange.max

END SELECT
END SUB

SUB __UI_TextChanged (id AS LONG)
SELECT CASE id
    CASE TextTT

END SELECT
END SUB

SUB __UI_ValueChanged (id AS LONG)
SELECT CASE id
    CASE TrackBar1

    CASE TrackBar3

END SELECT
END SUB

SUB ChangeParent (c1 AS LONG, c2 AS LONG)
Control(c1).ParentID = Control(c2).ID
Control(c1).ParentName = Control(c2).Name
END SUB



SUB sweepcontrols (from AS intpair, too AS intpair)
'an easy way to establish tab order
'NI: optionally change names ;* remember to scan for children controls and duplicate change
REDIM x AS _INTEGER64, y AS _INTEGER64, g(0) AS LONG
FOR x = from.a TO too.a
    FOR y = from.z TO too.z


NEXT: NEXT

END SUB

SUB ReadFile (spec$)
spec$ = "default"

IF _FILEEXISTS(spec$ + ".bil") THEN
ELSE
    PRINT "file name "; spec$; " not found in current path"
    EXIT SUB
END IF

REDIM dummy(0) AS room, dummys(0) AS roomsup: struc.size = LEN(dummy(0)): sup.size = LEN(dummys(0)): ERASE dummy, dummys

h1 = FREEFILE
OPEN spec$ + ".bil" FOR INPUT AS h1

mapdat$ = INPUT$(4, h1)


'discover sizes
IF LOF(h1) >= ver_h_size + 4 THEN mapdat$ = INPUT$(ver_h_size, h1)
mapver$ = RIGHT$(mapdat$, 8)
IF MID$(mapver$, 3, 1) = "." AND MID$(mapver$, 6, 1) = "." THEN
ELSE
    PRINT "format not recognized for file name "; spec$
    EXIT SUB
END IF

SHARED __incr_pos AS LONG
__incr_pos = ver_h_size 'len of what was already read


header_size = Readalong(h1)
Readsiz_rm = Readalong(h1)
Readsiz_pt = Readalong(h1)
Readsiz_ot = Readalong(h1)
Readsiz_cv = Readalong(h1)
nul$ = Readabunch(header_size - __incr_pos, h1)

loopquan = Readsiz_rm \ struc.size 'ln - header.size
REDIM _PRESERVE rooms(0 TO loopquan) AS room
FOR i = 0 TO loopquan
    mapdat$ = Readabunch(struc.size, h1)
    IF i > 0 THEN
        RT__room rooms(i), mapdat$
    ELSE
        DIM holder AS room
        RT__room holder, mapdat$
        '! set the rooms x and y vars = .now and .isof
    END IF
NEXT i


loopquan = Readsiz_pt \ struc.size

REDIM _PRESERVE paths(0 TO loopquan) AS room
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(struc.size, h1)
    RT__room paths(i), mapdat$
NEXT i

loopquan = Readsiz_ot \ sup.size

REDIM _PRESERVE visualchar(0 TO loopquan) AS roomsup
FOR i = 1 TO loopquan

    mapdat$ = Readabunch(sup.size, h1)
    RT__room paths(i), mapdat$
NEXT i

'custom values section

'mapdat$ = Readabunch(Readsiz_cv, h1)
mapdat$ = Readabunch(LOF(h1) - __incr_pos, h1)
IF LEN(mapdat$) > Readsiz_cv THEN
    'complain file length and header info don't match
END IF
'!process the c.d.


END SUB


SUB LoadResources

'primitive
IF _FILEEXISTS("res_mb/std.room.jpg") THEN reshandles(res_room) = _LOADIMAGE("res_mb/std.room.jpg")
END SUB

SUB PlaceToScale (bstatic AS _BYTE)
'destroying + remaking original controls may cause a problem w this procedure
STATIC __expand 'all left properties
IF bstatic = True THEN
    __expandLB = Control(MazeBuilder).Left - Control(expandLB).Left
    __ExpandBT = Control(MazeBuilder).Left - Control(ExpandBT).Left
    __Frame3 = Control(MazeBuilder).Left - Control(Frame3).Left
    __TrackBar1 = Control(MazeBuilder).Left - Control(TrackBar1).Left


ELSE

    Control(PictureBox1).Width = Control(PictureBox1).Width + (_RESIZEWIDTH - app.formwidth)
    '!'Control(PictureBox1).height=Control(PictureBox1).height+ (_resizeheight-app.formheight)
    cml = Control(MazeBuilder).Left
    Control(expandLB).Left = cml - __expandLB
    Control(ExpandBT).Left = cml - __ExpandBT
    Control(Frame3).Left = cml - __Frame3
    Control(TrackBar1).Left = cml - __TrackBar1
    '.
    '.
    '.
END IF
END SUB

SUB adjustzoom (factor)

'set up the scale variables
levels_defined = 8
DIM zoom_mults(levels_defined) AS SINGLE
zoom_mults(1) = 2.5
zoom_mults(2) = 1
zoom_mults(3) = 1 / 2
zoom_mults(4) = 1.3 / 3
zoom_mults(5) = 1 / 3
zoom_mults(6) = 1.4 / 4
zoom_mults(7) = 1 / 4
zoom_mults(8) = 1.5 / 5
zoom.level = zoom_mults(factor)
END SUB

SUB adjust_scroll (d, size AS LONG)

'scroll is defined to be a directed value between 1-10 divided into
' the ratio at the current zoom level of the total size of areadim.a,z (mixed with zoom.width;height) to the
' total h or w of the frame, Area,

'
' thus given a total size of areadim.a * zoom.width = 110 and 100 for Area width
'  scrollmag = (110 - 100) / (10 - 1)

'  scroll.top, scroll.left

scrmin = 1
scrmax = 10
scrolloutmult_thresh = .5

IF d = 1 THEN scrollmag = (areadim.a * zoom.width - Control(PictureBox1).Width) / (scrmax - scrmin)
IF d = 2 THEN scrollmag = (areadim.z * zoom.height - Control(PictureBox1).Height) / (scrmax - scrmin)
IF scrollmag <= 1 THEN EXIT SUB

DIM scrvec AS intpair
IF d = 1 AND scroll.left + size >= scrmin AND scroll.left + size <= scrmax THEN
    scrvec.a = size * scrollmag
ELSEIF d = 2 AND scroll.top + size >= scrmin AND scroll.top + size <= scrmax THEN
    scrvec.z = size * scrollmag
END IF


IF greater(scrvec.a, scrvec.z) <> 0 THEN ' if we are go to scroll
    'method std
    'horz mv
    si = SGN(scrvec.a) / 2: si2 = SGN(scrvec.z) / 2
    IF si THEN
        crunchct = scrvec.a \ greater(1, zoom.width) '-->ELSE crunchct = scrvec.z \ greater(1, zoom.height)
        FOR ix = 1 TO UBOUND(areaarr, 1)
            FOR iy = 1 TO UBOUND(areaarr, 2)

                __UI_DestroyControl Control(AreaArr(ix, iy))
        NEXT: NEXT
    ELSE crunchct = scrvec.z \ greater(1, zoom.height)
    END IF

    'having destroyed a row(s) or a column(s), seek down or up for the first still-existing frame
    '   if movement was leftward or upward (neg): subtract a quantity from each still existing AreaArr 's ID
    '   if movement was rightward or downward (neg):add a quantity to each still existing AreaArr 's ID
    '   then produce the number of widgets that got destroyed, and alter their ID to be what content of AreaArr 's are not existing
    '... re-filling frame widgets with PB widgets as we go

END IF
'  controlrange.min = AreaArr(1, 1): controlrange.max = AreaArr(areadim.a, areadim.z)


END SUB


SUB RT__room (t AS room, d$)
DIM i AS _UNSIGNED INTEGER, size AS _UNSIGNED INTEGER, ftesize AS _UNSIGNED INTEGER
DIM m AS _MEM, pt AS _OFFSET, deco AS _BYTE
size = LEN(t): m = _MEM(t)
FOR i = 1 TO size
    deco = _CV(_BYTE, MID$(d$, i, 1))
    _MEMPUT m, m.OFFSET + i - 1, deco
NEXT i
END SUB

FUNCTION NextTime! (timedelta AS SINGLE)
NextTime! = (TIMER(.001) + timedelta) MOD 86400 'just prevent out of bounds values when comparing TIMER output
END FUNCTION


FUNCTION greater## (c1##, c2##): IF c1## > c2## THEN greater## = c1## ELSE greater## = c2##
END FUNCTION

FUNCTION Readabunch$ (size AS LONG, hfile AS LONG)
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + size
IF hfile THEN Readabunch$ = INPUT$(size, hfile)
END FUNCTION

FUNCTION Readalong& (hfile AS LONG)
SHARED __incr_pos AS LONG
__incr_pos = __incr_pos + LEN(a&)
IF hfile THEN Readalong& = CVL(INPUT$(4, hfile))
END FUNCTION



SUB diagnosticalinit


app.formwidth = 1024
app.formheight = 768
app.roomwidth = 80: app.roomheight = 53
zoom.level = 1

END SUB
FUNCTION zoom.width ()
zoom.width = app.roomwidth * zoom.level: END FUNCTION
FUNCTION zoom.height ()
zoom.height = app.roomheight * zoom.level: END FUNCTION

SUB prot_setZoomValue (zscl AS SINGLE)


'NI

END SUB
